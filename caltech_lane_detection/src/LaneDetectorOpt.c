/*
  File autogenerated by gengetopt version 2.18
  generated with the following command:
  gengetopt -i LaneDetectorOpt.ggo --conf-parser -F LaneDetectorOpt --func-name=LaneDetectorParser --arg-struct-name=LaneDetectorParserInfo

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "getopt.h"

#include "LaneDetectorOpt.h"

const char *LaneDetectorParserInfo_purpose = "";

const char *LaneDetectorParserInfo_usage = "Usage: LaneDetector [OPTIONS]...";

const char *LaneDetectorParserInfo_help[] = {
  "  -h, --help                    Print help and exit",
  "  -V, --version                 Print version and exit",
  "      --ipmWidth=INT            width of IPM image to use",
  "      --ipmHeight=INT           height of IPM image to use",
  "      --ipmTop=INT              Top point in original image of region to make \n                                  IPM for",
  "      --ipmLeft=INT             Left point in original image of region to make \n                                  IPM for",
  "      --ipmRight=INT            Right point in original image region to make \n                                  IPM for",
  "      --ipmBottom=INT           Bottom point in original image region to make \n                                  IPM for",
  "      --ipmInterpolation=INT    The method to use for IPM interpolation",
  "      --lineWidth=DOUBLE        width of line to detect in mm (in the world)",
  "      --lineHeight=DOUBLE       height of line to detect in mm (in the world)",
  "      --kernelWidth=INT         widht of kernel to use for filtering",
  "      --kernelHeight=INT        Height of kernel to use for filtering",
  "      --lowerQuantile=DOUBLE    lower quantile to use for thresholding the \n                                  filtered image",
  "      --localMaxima=INT         whether to return local maxima or just the \n                                  maximum",
  "      --groupingType=INT        type of grouping to use (default 0: HV lines)",
  "      --binarize=DOUBLE         whether to binarize the thresholded image or \n                                  use the raw values",
  "      --detectionThreshold=DOUBLE\n                                threshold for line scores to declare as line",
  "      --smoothScores=INT        whether to smooth scores of lines detected or \n                                  not",
  "      --rMin=DOUBLE             rMin for Hough transform (in pixels)",
  "      --rMax=DOUBLE             rMax for Hough transform (in pixels)",
  "      --rStep=DOUBLE            rStep for Hough transform (in pixels)",
  "      --thetaMin=DOUBLE         thetaMin for Hough transform (in degrees)",
  "      --thetaMax=DOUBLE         thetaMax for Hough transform (in degrees)",
  "      --thetaStep=DOUBLE        thetaStep for Hough transform (in degrees)",
  "      --ipmVpPortion=DOUBLE     Portion of IPM image height to add to \n                                  y-coordinate of VP",
  "      --getEndPoints=INT        Get the endpoints of the line",
  "      --group=INT               group nearby lines or not (default 1: group)",
  "      --groupThreshold=DOUBLE   Threshold for grouping nearby lines (default \n                                  10)",
  "      --ransac=INT              use RANSAC (1) or not (0)",
  "      --ransacLineNumSamples=INT\n                                Number of samples to use for RANSAC",
  "      --ransacLineNumIterations=INT\n                                Number of iterations to use for RANSAC",
  "      --ransacLineNumGoodFit=INT\n                                Number of close points to consider a good line \n                                  fit",
  "      --ransacLineThreshold=DOUBLE\n                                Threshold to consider a point close",
  "      --ransacLineScoreThreshold=DOUBLE\n                                Threshold for detected line scores",
  "      --ransacLineBinarize=INT  Whether to binarize image for RANSAC or not",
  "      --ransacLineWindow=INT    Half width to use for ransac window",
  "      --ransacSplineNumSamples=INT\n                                Number of samples to use for RANSAC",
  "      --ransacSplineNumIterations=INT\n                                Number of iterations to use for RANSAC",
  "      --ransacSplineNumGoodFit=INT\n                                Number of close points to consider a good line \n                                  fit",
  "      --ransacSplineThreshold=DOUBLE\n                                Threshold to consider a point close",
  "      --ransacSplineScoreThreshold=DOUBLE\n                                Threshold for detected line scores",
  "      --ransacSplineBinarize=INT\n                                Whether to binarize image for RANSAC or not",
  "      --ransacSplineWindow=INT  Half width to use for ransac window",
  "      --ransacSplineDegree=INT  Degree of spline to use",
  "      --ransacSpline=INT        Whether to use splines",
  "      --ransacLine=INT          Whether to use lines",
  "      --ransacSplineStep=FLOAT  Step to use when pixelzing spline in ransac",
  "      --overlapThreshold=FLOAT  Overlap threshold to use for grouping of \n                                  bounding boxes",
  "      --localizeAngleThreshold=FLOAT\n                                Angle threshold used for localization (cosine, \n                                  1: most restrictive, 0: most liberal)",
  "      --localizeNumLinePixels=INT\n                                Number of pixels to go in normal direction for \n                                  localization",
  "      --extendAngleThreshold=FLOAT\n                                Angle threshold used for extending (cosine, 1: \n                                  most restrictive, 0: most liberal)",
  "      --extendMeanDirAngleThreshold=FLOAT\n                                Angle threshold from mean direction used for \n                                  extending (cosine, 1: most restrictive, 0: \n                                  most liberal)",
  "      --extendLinePixelsTangent=INT\n                                Number of pixels to go in tangent direction for \n                                  extending",
  "      --extendLinePixelsNormal=INT\n                                Number of pixels to go in tangent direction for \n                                  extending",
  "      --extendContThreshold=FLOAT\n                                Threhsold used for stopping the extending \n                                  process (higher -> less extending)",
  "      --extendDeviationThreshold=INT\n                                Stop extending when number of deviating points \n                                  exceeds this threshold",
  "      --extendRectTop=INT       Top point for extension bounding box",
  "      --extendRectBottom=INT    Bottom point for extension bounding box",
  "      --extendIPMAngleThreshold=FLOAT\n                                Angle threshold used for extending (cosine, 1: \n                                  most restrictive, 0: most liberal)",
  "      --extendIPMMeanDirAngleThreshold=FLOAT\n                                Angle threshold from mean direction used for \n                                  extending (cosine, 1: most restrictive, 0: \n                                  most liberal)",
  "      --extendIPMLinePixelsTangent=INT\n                                Number of pixels to go in tangent direction for \n                                  extending",
  "      --extendIPMLinePixelsNormal=INT\n                                Number of pixels to go in tangent direction for \n                                  extending",
  "      --extendIPMContThreshold=FLOAT\n                                Threhsold used for stopping the extending \n                                  process (higher -> less extending)",
  "      --extendIPMDeviationThreshold=INT\n                                Stop extending when number of deviating points \n                                  exceeds this threshold",
  "      --extendIPMRectTop=INT    Top point for extension bounding box",
  "      --extendIPMRectBottom=INT Bottom point for extension bounding box",
  "      --splineScoreJitter=INT   Number of pixels to go around the spline to \n                                  compute score",
  "      --splineScoreLengthRatio=FLOAT\n                                Ratio of spline length to use",
  "      --splineScoreAngleRatio=FLOAT\n                                Ratio of spline angle to use",
  "      --splineScoreStep=FLOAT   Step to use for spline score computation",
  "      --splineTrackingNumAbsentFrames=INT\n                                number of frames the track is allowed to be \n                                  absent before deleting it",
  "      --splineTrackingNumSeenFrames=INT\n                                number of frames before considering the track \n                                  good",
  "      --mergeSplineThetaThreshold=FLOAT\n                                Angle threshold for merging splines (radians)",
  "      --mergeSplineRThreshold=FLOAT\n                                R threshold (distance from origin) for merginn \n                                  splines",
  "      --mergeSplineMeanThetaThreshold=FLOAT\n                                Mean Angle threshold for merging splines \n                                  (radians)",
  "      --mergeSplineMeanRThreshold=FLOAT\n                                Mean R threshold (distance from origin) for \n                                  merginn splines",
  "      --mergeSplineCentroidThreshold=FLOAT\n                                Distance threshold between spline cetroids for \n                                  merging",
  "      --lineTrackingNumAbsentFrames=INT\n                                number of frames the track is allowed to be \n                                  absent before deleting it",
  "      --lineTrackingNumSeenFrames=INT\n                                number of frames before considering the track \n                                  good",
  "      --mergeLineThetaThreshold=FLOAT\n                                Angle threshold for merging lines (radians)",
  "      --mergeLineRThreshold=FLOAT\n                                R threshold (distance from origin) for merging \n                                  lines",
  "      --numStrips=INT           Number of horizontal strips to divide the image \n                                  to",
  "      --checkSplines=INT        Whtethet to check splines or not",
  "      --checkSplinesCurvenessThreshold=FLOAT\n                                Curveness Threshold for checking splines",
  "      --checkSplinesLengthThreshold=FLOAT\n                                Length Threshold for checking splines",
  "      --checkSplinesThetaDiffThreshold=FLOAT\n                                ThetaDiff Threshold for checking splines",
  "      --checkSplinesThetaThreshold=FLOAT\n                                ThetaThreshold Threshold for checking splines",
  "      --checkIPMSplines=INT     Whtethet to check IPM splines or not",
  "      --checkIPMSplinesCurvenessThreshold=FLOAT\n                                Curveness Threshold for checking splines",
  "      --checkIPMSplinesLengthThreshold=FLOAT\n                                Length Threshold for checking splines",
  "      --checkIPMSplinesThetaDiffThreshold=FLOAT\n                                ThetaDiff Threshold for checking splines",
  "      --checkIPMSplinesThetaThreshold=FLOAT\n                                ThetaThreshold Threshold for checking splines",
  "      --finalSplineScoreThreshold=FLOAT\n                                Final Threshold for declaring a valid spline",
  "      --useGroundPlane=INT      Use groudn plane or not when sending to map",
  "      --checkColor=INT          Whether to check colors or not",
  "      --checkColorWindow=INT    Size of window to use",
  "      --checkColorNumBins=INT   Number of bins to use",
  "      --checkColorNumYellowMin=FLOAT\n                                Min ratio of yellow points",
  "      --checkColorRGMin=FLOAT   Min RG diff",
  "      --checkColorRGMax=FLOAT   Max RG diff",
  "      --checkColorGBMin=FLOAT   Min GB diff",
  "      --checkColorRBMin=FLOAT   Min RB diff",
  "      --checkColorRBFThreshold=FLOAT\n                                RBF Threshold",
  "      --checkColorRBF=INT       Whether to use RBF or not",
  "      --ipmWindowClear=INT      Whether to clear part of the IPM image",
  "      --ipmWindowLeft=INT       Left corrdinate of window to keep in IPM",
  "      --ipmWindowRight=INT      Left corrdinate of window to keep in IPM",
  "      --checkLaneWidth=INT      Whether to check lane width or not",
  "      --checkLaneWidthMean=FLOAT\n                                Mean of lane width to look for",
  "      --checkLaneWidthStd=FLOAT Std deviation of lane width to look for",
    0
};

static
void clear_given (struct LaneDetectorParserInfo *args_info);
static
void clear_args (struct LaneDetectorParserInfo *args_info);

static int
LaneDetectorParser_internal (int argc, char * const *argv, struct LaneDetectorParserInfo *args_info, int override, int initialize, int check_required, const char *additional_error);

static int
LaneDetectorParser_required2 (struct LaneDetectorParserInfo *args_info, const char *prog_name, const char *additional_error);
struct line_list
{
  char * string_arg;
  struct line_list * next;
};

static struct line_list *cmd_line_list = 0;
static struct line_list *cmd_line_list_tmp = 0;

static void
free_cmd_list(void)
{
  /* free the list of a previous call */
  if (cmd_line_list)
    {
      while (cmd_line_list) {
        cmd_line_list_tmp = cmd_line_list;
        cmd_line_list = cmd_line_list->next;
        free (cmd_line_list_tmp->string_arg);
        free (cmd_line_list_tmp);
      }
    }
}


static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct LaneDetectorParserInfo *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->ipmWidth_given = 0 ;
  args_info->ipmHeight_given = 0 ;
  args_info->ipmTop_given = 0 ;
  args_info->ipmLeft_given = 0 ;
  args_info->ipmRight_given = 0 ;
  args_info->ipmBottom_given = 0 ;
  args_info->ipmInterpolation_given = 0 ;
  args_info->lineWidth_given = 0 ;
  args_info->lineHeight_given = 0 ;
  args_info->kernelWidth_given = 0 ;
  args_info->kernelHeight_given = 0 ;
  args_info->lowerQuantile_given = 0 ;
  args_info->localMaxima_given = 0 ;
  args_info->groupingType_given = 0 ;
  args_info->binarize_given = 0 ;
  args_info->detectionThreshold_given = 0 ;
  args_info->smoothScores_given = 0 ;
  args_info->rMin_given = 0 ;
  args_info->rMax_given = 0 ;
  args_info->rStep_given = 0 ;
  args_info->thetaMin_given = 0 ;
  args_info->thetaMax_given = 0 ;
  args_info->thetaStep_given = 0 ;
  args_info->ipmVpPortion_given = 0 ;
  args_info->getEndPoints_given = 0 ;
  args_info->group_given = 0 ;
  args_info->groupThreshold_given = 0 ;
  args_info->ransac_given = 0 ;
  args_info->ransacLineNumSamples_given = 0 ;
  args_info->ransacLineNumIterations_given = 0 ;
  args_info->ransacLineNumGoodFit_given = 0 ;
  args_info->ransacLineThreshold_given = 0 ;
  args_info->ransacLineScoreThreshold_given = 0 ;
  args_info->ransacLineBinarize_given = 0 ;
  args_info->ransacLineWindow_given = 0 ;
  args_info->ransacSplineNumSamples_given = 0 ;
  args_info->ransacSplineNumIterations_given = 0 ;
  args_info->ransacSplineNumGoodFit_given = 0 ;
  args_info->ransacSplineThreshold_given = 0 ;
  args_info->ransacSplineScoreThreshold_given = 0 ;
  args_info->ransacSplineBinarize_given = 0 ;
  args_info->ransacSplineWindow_given = 0 ;
  args_info->ransacSplineDegree_given = 0 ;
  args_info->ransacSpline_given = 0 ;
  args_info->ransacLine_given = 0 ;
  args_info->ransacSplineStep_given = 0 ;
  args_info->overlapThreshold_given = 0 ;
  args_info->localizeAngleThreshold_given = 0 ;
  args_info->localizeNumLinePixels_given = 0 ;
  args_info->extendAngleThreshold_given = 0 ;
  args_info->extendMeanDirAngleThreshold_given = 0 ;
  args_info->extendLinePixelsTangent_given = 0 ;
  args_info->extendLinePixelsNormal_given = 0 ;
  args_info->extendContThreshold_given = 0 ;
  args_info->extendDeviationThreshold_given = 0 ;
  args_info->extendRectTop_given = 0 ;
  args_info->extendRectBottom_given = 0 ;
  args_info->extendIPMAngleThreshold_given = 0 ;
  args_info->extendIPMMeanDirAngleThreshold_given = 0 ;
  args_info->extendIPMLinePixelsTangent_given = 0 ;
  args_info->extendIPMLinePixelsNormal_given = 0 ;
  args_info->extendIPMContThreshold_given = 0 ;
  args_info->extendIPMDeviationThreshold_given = 0 ;
  args_info->extendIPMRectTop_given = 0 ;
  args_info->extendIPMRectBottom_given = 0 ;
  args_info->splineScoreJitter_given = 0 ;
  args_info->splineScoreLengthRatio_given = 0 ;
  args_info->splineScoreAngleRatio_given = 0 ;
  args_info->splineScoreStep_given = 0 ;
  args_info->splineTrackingNumAbsentFrames_given = 0 ;
  args_info->splineTrackingNumSeenFrames_given = 0 ;
  args_info->mergeSplineThetaThreshold_given = 0 ;
  args_info->mergeSplineRThreshold_given = 0 ;
  args_info->mergeSplineMeanThetaThreshold_given = 0 ;
  args_info->mergeSplineMeanRThreshold_given = 0 ;
  args_info->mergeSplineCentroidThreshold_given = 0 ;
  args_info->lineTrackingNumAbsentFrames_given = 0 ;
  args_info->lineTrackingNumSeenFrames_given = 0 ;
  args_info->mergeLineThetaThreshold_given = 0 ;
  args_info->mergeLineRThreshold_given = 0 ;
  args_info->numStrips_given = 0 ;
  args_info->checkSplines_given = 0 ;
  args_info->checkSplinesCurvenessThreshold_given = 0 ;
  args_info->checkSplinesLengthThreshold_given = 0 ;
  args_info->checkSplinesThetaDiffThreshold_given = 0 ;
  args_info->checkSplinesThetaThreshold_given = 0 ;
  args_info->checkIPMSplines_given = 0 ;
  args_info->checkIPMSplinesCurvenessThreshold_given = 0 ;
  args_info->checkIPMSplinesLengthThreshold_given = 0 ;
  args_info->checkIPMSplinesThetaDiffThreshold_given = 0 ;
  args_info->checkIPMSplinesThetaThreshold_given = 0 ;
  args_info->finalSplineScoreThreshold_given = 0 ;
  args_info->useGroundPlane_given = 0 ;
  args_info->checkColor_given = 0 ;
  args_info->checkColorWindow_given = 0 ;
  args_info->checkColorNumBins_given = 0 ;
  args_info->checkColorNumYellowMin_given = 0 ;
  args_info->checkColorRGMin_given = 0 ;
  args_info->checkColorRGMax_given = 0 ;
  args_info->checkColorGBMin_given = 0 ;
  args_info->checkColorRBMin_given = 0 ;
  args_info->checkColorRBFThreshold_given = 0 ;
  args_info->checkColorRBF_given = 0 ;
  args_info->ipmWindowClear_given = 0 ;
  args_info->ipmWindowLeft_given = 0 ;
  args_info->ipmWindowRight_given = 0 ;
  args_info->checkLaneWidth_given = 0 ;
  args_info->checkLaneWidthMean_given = 0 ;
  args_info->checkLaneWidthStd_given = 0 ;
}

static
void clear_args (struct LaneDetectorParserInfo *args_info)
{
  args_info->ipmWidth_orig = NULL;
  args_info->ipmHeight_orig = NULL;
  args_info->ipmTop_orig = NULL;
  args_info->ipmLeft_orig = NULL;
  args_info->ipmRight_orig = NULL;
  args_info->ipmBottom_orig = NULL;
  args_info->ipmInterpolation_orig = NULL;
  args_info->lineWidth_orig = NULL;
  args_info->lineHeight_orig = NULL;
  args_info->kernelWidth_orig = NULL;
  args_info->kernelHeight_orig = NULL;
  args_info->lowerQuantile_orig = NULL;
  args_info->localMaxima_orig = NULL;
  args_info->groupingType_orig = NULL;
  args_info->binarize_orig = NULL;
  args_info->detectionThreshold_orig = NULL;
  args_info->smoothScores_orig = NULL;
  args_info->rMin_orig = NULL;
  args_info->rMax_orig = NULL;
  args_info->rStep_orig = NULL;
  args_info->thetaMin_orig = NULL;
  args_info->thetaMax_orig = NULL;
  args_info->thetaStep_orig = NULL;
  args_info->ipmVpPortion_orig = NULL;
  args_info->getEndPoints_orig = NULL;
  args_info->group_orig = NULL;
  args_info->groupThreshold_orig = NULL;
  args_info->ransac_orig = NULL;
  args_info->ransacLineNumSamples_orig = NULL;
  args_info->ransacLineNumIterations_orig = NULL;
  args_info->ransacLineNumGoodFit_orig = NULL;
  args_info->ransacLineThreshold_orig = NULL;
  args_info->ransacLineScoreThreshold_orig = NULL;
  args_info->ransacLineBinarize_orig = NULL;
  args_info->ransacLineWindow_orig = NULL;
  args_info->ransacSplineNumSamples_orig = NULL;
  args_info->ransacSplineNumIterations_orig = NULL;
  args_info->ransacSplineNumGoodFit_orig = NULL;
  args_info->ransacSplineThreshold_orig = NULL;
  args_info->ransacSplineScoreThreshold_orig = NULL;
  args_info->ransacSplineBinarize_orig = NULL;
  args_info->ransacSplineWindow_orig = NULL;
  args_info->ransacSplineDegree_orig = NULL;
  args_info->ransacSpline_orig = NULL;
  args_info->ransacLine_orig = NULL;
  args_info->ransacSplineStep_orig = NULL;
  args_info->overlapThreshold_orig = NULL;
  args_info->localizeAngleThreshold_orig = NULL;
  args_info->localizeNumLinePixels_orig = NULL;
  args_info->extendAngleThreshold_orig = NULL;
  args_info->extendMeanDirAngleThreshold_orig = NULL;
  args_info->extendLinePixelsTangent_orig = NULL;
  args_info->extendLinePixelsNormal_orig = NULL;
  args_info->extendContThreshold_orig = NULL;
  args_info->extendDeviationThreshold_orig = NULL;
  args_info->extendRectTop_orig = NULL;
  args_info->extendRectBottom_orig = NULL;
  args_info->extendIPMAngleThreshold_orig = NULL;
  args_info->extendIPMMeanDirAngleThreshold_orig = NULL;
  args_info->extendIPMLinePixelsTangent_orig = NULL;
  args_info->extendIPMLinePixelsNormal_orig = NULL;
  args_info->extendIPMContThreshold_orig = NULL;
  args_info->extendIPMDeviationThreshold_orig = NULL;
  args_info->extendIPMRectTop_orig = NULL;
  args_info->extendIPMRectBottom_orig = NULL;
  args_info->splineScoreJitter_orig = NULL;
  args_info->splineScoreLengthRatio_orig = NULL;
  args_info->splineScoreAngleRatio_orig = NULL;
  args_info->splineScoreStep_orig = NULL;
  args_info->splineTrackingNumAbsentFrames_orig = NULL;
  args_info->splineTrackingNumSeenFrames_orig = NULL;
  args_info->mergeSplineThetaThreshold_orig = NULL;
  args_info->mergeSplineRThreshold_orig = NULL;
  args_info->mergeSplineMeanThetaThreshold_orig = NULL;
  args_info->mergeSplineMeanRThreshold_orig = NULL;
  args_info->mergeSplineCentroidThreshold_orig = NULL;
  args_info->lineTrackingNumAbsentFrames_orig = NULL;
  args_info->lineTrackingNumSeenFrames_orig = NULL;
  args_info->mergeLineThetaThreshold_orig = NULL;
  args_info->mergeLineRThreshold_orig = NULL;
  args_info->numStrips_orig = NULL;
  args_info->checkSplines_orig = NULL;
  args_info->checkSplinesCurvenessThreshold_orig = NULL;
  args_info->checkSplinesLengthThreshold_orig = NULL;
  args_info->checkSplinesThetaDiffThreshold_orig = NULL;
  args_info->checkSplinesThetaThreshold_orig = NULL;
  args_info->checkIPMSplines_orig = NULL;
  args_info->checkIPMSplinesCurvenessThreshold_orig = NULL;
  args_info->checkIPMSplinesLengthThreshold_orig = NULL;
  args_info->checkIPMSplinesThetaDiffThreshold_orig = NULL;
  args_info->checkIPMSplinesThetaThreshold_orig = NULL;
  args_info->finalSplineScoreThreshold_orig = NULL;
  args_info->useGroundPlane_orig = NULL;
  args_info->checkColor_orig = NULL;
  args_info->checkColorWindow_orig = NULL;
  args_info->checkColorNumBins_orig = NULL;
  args_info->checkColorNumYellowMin_orig = NULL;
  args_info->checkColorRGMin_orig = NULL;
  args_info->checkColorRGMax_orig = NULL;
  args_info->checkColorGBMin_orig = NULL;
  args_info->checkColorRBMin_orig = NULL;
  args_info->checkColorRBFThreshold_orig = NULL;
  args_info->checkColorRBF_orig = NULL;
  args_info->ipmWindowClear_orig = NULL;
  args_info->ipmWindowLeft_orig = NULL;
  args_info->ipmWindowRight_orig = NULL;
  args_info->checkLaneWidth_orig = NULL;
  args_info->checkLaneWidthMean_orig = NULL;
  args_info->checkLaneWidthStd_orig = NULL;

}

static
void init_args_info(struct LaneDetectorParserInfo *args_info)
{
  args_info->help_help = LaneDetectorParserInfo_help[0] ;
  args_info->version_help = LaneDetectorParserInfo_help[1] ;
  args_info->ipmWidth_help = LaneDetectorParserInfo_help[2] ;
  args_info->ipmHeight_help = LaneDetectorParserInfo_help[3] ;
  args_info->ipmTop_help = LaneDetectorParserInfo_help[4] ;
  args_info->ipmLeft_help = LaneDetectorParserInfo_help[5] ;
  args_info->ipmRight_help = LaneDetectorParserInfo_help[6] ;
  args_info->ipmBottom_help = LaneDetectorParserInfo_help[7] ;
  args_info->ipmInterpolation_help = LaneDetectorParserInfo_help[8] ;
  args_info->lineWidth_help = LaneDetectorParserInfo_help[9] ;
  args_info->lineHeight_help = LaneDetectorParserInfo_help[10] ;
  args_info->kernelWidth_help = LaneDetectorParserInfo_help[11] ;
  args_info->kernelHeight_help = LaneDetectorParserInfo_help[12] ;
  args_info->lowerQuantile_help = LaneDetectorParserInfo_help[13] ;
  args_info->localMaxima_help = LaneDetectorParserInfo_help[14] ;
  args_info->groupingType_help = LaneDetectorParserInfo_help[15] ;
  args_info->binarize_help = LaneDetectorParserInfo_help[16] ;
  args_info->detectionThreshold_help = LaneDetectorParserInfo_help[17] ;
  args_info->smoothScores_help = LaneDetectorParserInfo_help[18] ;
  args_info->rMin_help = LaneDetectorParserInfo_help[19] ;
  args_info->rMax_help = LaneDetectorParserInfo_help[20] ;
  args_info->rStep_help = LaneDetectorParserInfo_help[21] ;
  args_info->thetaMin_help = LaneDetectorParserInfo_help[22] ;
  args_info->thetaMax_help = LaneDetectorParserInfo_help[23] ;
  args_info->thetaStep_help = LaneDetectorParserInfo_help[24] ;
  args_info->ipmVpPortion_help = LaneDetectorParserInfo_help[25] ;
  args_info->getEndPoints_help = LaneDetectorParserInfo_help[26] ;
  args_info->group_help = LaneDetectorParserInfo_help[27] ;
  args_info->groupThreshold_help = LaneDetectorParserInfo_help[28] ;
  args_info->ransac_help = LaneDetectorParserInfo_help[29] ;
  args_info->ransacLineNumSamples_help = LaneDetectorParserInfo_help[30] ;
  args_info->ransacLineNumIterations_help = LaneDetectorParserInfo_help[31] ;
  args_info->ransacLineNumGoodFit_help = LaneDetectorParserInfo_help[32] ;
  args_info->ransacLineThreshold_help = LaneDetectorParserInfo_help[33] ;
  args_info->ransacLineScoreThreshold_help = LaneDetectorParserInfo_help[34] ;
  args_info->ransacLineBinarize_help = LaneDetectorParserInfo_help[35] ;
  args_info->ransacLineWindow_help = LaneDetectorParserInfo_help[36] ;
  args_info->ransacSplineNumSamples_help = LaneDetectorParserInfo_help[37] ;
  args_info->ransacSplineNumIterations_help = LaneDetectorParserInfo_help[38] ;
  args_info->ransacSplineNumGoodFit_help = LaneDetectorParserInfo_help[39] ;
  args_info->ransacSplineThreshold_help = LaneDetectorParserInfo_help[40] ;
  args_info->ransacSplineScoreThreshold_help = LaneDetectorParserInfo_help[41] ;
  args_info->ransacSplineBinarize_help = LaneDetectorParserInfo_help[42] ;
  args_info->ransacSplineWindow_help = LaneDetectorParserInfo_help[43] ;
  args_info->ransacSplineDegree_help = LaneDetectorParserInfo_help[44] ;
  args_info->ransacSpline_help = LaneDetectorParserInfo_help[45] ;
  args_info->ransacLine_help = LaneDetectorParserInfo_help[46] ;
  args_info->ransacSplineStep_help = LaneDetectorParserInfo_help[47] ;
  args_info->overlapThreshold_help = LaneDetectorParserInfo_help[48] ;
  args_info->localizeAngleThreshold_help = LaneDetectorParserInfo_help[49] ;
  args_info->localizeNumLinePixels_help = LaneDetectorParserInfo_help[50] ;
  args_info->extendAngleThreshold_help = LaneDetectorParserInfo_help[51] ;
  args_info->extendMeanDirAngleThreshold_help = LaneDetectorParserInfo_help[52] ;
  args_info->extendLinePixelsTangent_help = LaneDetectorParserInfo_help[53] ;
  args_info->extendLinePixelsNormal_help = LaneDetectorParserInfo_help[54] ;
  args_info->extendContThreshold_help = LaneDetectorParserInfo_help[55] ;
  args_info->extendDeviationThreshold_help = LaneDetectorParserInfo_help[56] ;
  args_info->extendRectTop_help = LaneDetectorParserInfo_help[57] ;
  args_info->extendRectBottom_help = LaneDetectorParserInfo_help[58] ;
  args_info->extendIPMAngleThreshold_help = LaneDetectorParserInfo_help[59] ;
  args_info->extendIPMMeanDirAngleThreshold_help = LaneDetectorParserInfo_help[60] ;
  args_info->extendIPMLinePixelsTangent_help = LaneDetectorParserInfo_help[61] ;
  args_info->extendIPMLinePixelsNormal_help = LaneDetectorParserInfo_help[62] ;
  args_info->extendIPMContThreshold_help = LaneDetectorParserInfo_help[63] ;
  args_info->extendIPMDeviationThreshold_help = LaneDetectorParserInfo_help[64] ;
  args_info->extendIPMRectTop_help = LaneDetectorParserInfo_help[65] ;
  args_info->extendIPMRectBottom_help = LaneDetectorParserInfo_help[66] ;
  args_info->splineScoreJitter_help = LaneDetectorParserInfo_help[67] ;
  args_info->splineScoreLengthRatio_help = LaneDetectorParserInfo_help[68] ;
  args_info->splineScoreAngleRatio_help = LaneDetectorParserInfo_help[69] ;
  args_info->splineScoreStep_help = LaneDetectorParserInfo_help[70] ;
  args_info->splineTrackingNumAbsentFrames_help = LaneDetectorParserInfo_help[71] ;
  args_info->splineTrackingNumSeenFrames_help = LaneDetectorParserInfo_help[72] ;
  args_info->mergeSplineThetaThreshold_help = LaneDetectorParserInfo_help[73] ;
  args_info->mergeSplineRThreshold_help = LaneDetectorParserInfo_help[74] ;
  args_info->mergeSplineMeanThetaThreshold_help = LaneDetectorParserInfo_help[75] ;
  args_info->mergeSplineMeanRThreshold_help = LaneDetectorParserInfo_help[76] ;
  args_info->mergeSplineCentroidThreshold_help = LaneDetectorParserInfo_help[77] ;
  args_info->lineTrackingNumAbsentFrames_help = LaneDetectorParserInfo_help[78] ;
  args_info->lineTrackingNumSeenFrames_help = LaneDetectorParserInfo_help[79] ;
  args_info->mergeLineThetaThreshold_help = LaneDetectorParserInfo_help[80] ;
  args_info->mergeLineRThreshold_help = LaneDetectorParserInfo_help[81] ;
  args_info->numStrips_help = LaneDetectorParserInfo_help[82] ;
  args_info->checkSplines_help = LaneDetectorParserInfo_help[83] ;
  args_info->checkSplinesCurvenessThreshold_help = LaneDetectorParserInfo_help[84] ;
  args_info->checkSplinesLengthThreshold_help = LaneDetectorParserInfo_help[85] ;
  args_info->checkSplinesThetaDiffThreshold_help = LaneDetectorParserInfo_help[86] ;
  args_info->checkSplinesThetaThreshold_help = LaneDetectorParserInfo_help[87] ;
  args_info->checkIPMSplines_help = LaneDetectorParserInfo_help[88] ;
  args_info->checkIPMSplinesCurvenessThreshold_help = LaneDetectorParserInfo_help[89] ;
  args_info->checkIPMSplinesLengthThreshold_help = LaneDetectorParserInfo_help[90] ;
  args_info->checkIPMSplinesThetaDiffThreshold_help = LaneDetectorParserInfo_help[91] ;
  args_info->checkIPMSplinesThetaThreshold_help = LaneDetectorParserInfo_help[92] ;
  args_info->finalSplineScoreThreshold_help = LaneDetectorParserInfo_help[93] ;
  args_info->useGroundPlane_help = LaneDetectorParserInfo_help[94] ;
  args_info->checkColor_help = LaneDetectorParserInfo_help[95] ;
  args_info->checkColorWindow_help = LaneDetectorParserInfo_help[96] ;
  args_info->checkColorNumBins_help = LaneDetectorParserInfo_help[97] ;
  args_info->checkColorNumYellowMin_help = LaneDetectorParserInfo_help[98] ;
  args_info->checkColorRGMin_help = LaneDetectorParserInfo_help[99] ;
  args_info->checkColorRGMax_help = LaneDetectorParserInfo_help[100] ;
  args_info->checkColorGBMin_help = LaneDetectorParserInfo_help[101] ;
  args_info->checkColorRBMin_help = LaneDetectorParserInfo_help[102] ;
  args_info->checkColorRBFThreshold_help = LaneDetectorParserInfo_help[103] ;
  args_info->checkColorRBF_help = LaneDetectorParserInfo_help[104] ;
  args_info->ipmWindowClear_help = LaneDetectorParserInfo_help[105] ;
  args_info->ipmWindowLeft_help = LaneDetectorParserInfo_help[106] ;
  args_info->ipmWindowRight_help = LaneDetectorParserInfo_help[107] ;
  args_info->checkLaneWidth_help = LaneDetectorParserInfo_help[108] ;
  args_info->checkLaneWidthMean_help = LaneDetectorParserInfo_help[109] ;
  args_info->checkLaneWidthStd_help = LaneDetectorParserInfo_help[110] ;

}

void
LaneDetectorParser_print_version (void)
{
  printf ("%s %s\n", LANEDETECTORPARSER_PACKAGE, LANEDETECTORPARSER_VERSION);
}

void
LaneDetectorParser_print_help (void)
{
  int i = 0;
  LaneDetectorParser_print_version ();

  if (strlen(LaneDetectorParserInfo_purpose) > 0)
    printf("\n%s\n", LaneDetectorParserInfo_purpose);

  printf("\n%s\n\n", LaneDetectorParserInfo_usage);
  while (LaneDetectorParserInfo_help[i])
    printf("%s\n", LaneDetectorParserInfo_help[i++]);
}

void
LaneDetectorParser_init (struct LaneDetectorParserInfo *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);
}

static void
LaneDetectorParser_release (struct LaneDetectorParserInfo *args_info)
{

  if (args_info->ipmWidth_orig)
    {
      free (args_info->ipmWidth_orig); /* free previous argument */
      args_info->ipmWidth_orig = 0;
    }
  if (args_info->ipmHeight_orig)
    {
      free (args_info->ipmHeight_orig); /* free previous argument */
      args_info->ipmHeight_orig = 0;
    }
  if (args_info->ipmTop_orig)
    {
      free (args_info->ipmTop_orig); /* free previous argument */
      args_info->ipmTop_orig = 0;
    }
  if (args_info->ipmLeft_orig)
    {
      free (args_info->ipmLeft_orig); /* free previous argument */
      args_info->ipmLeft_orig = 0;
    }
  if (args_info->ipmRight_orig)
    {
      free (args_info->ipmRight_orig); /* free previous argument */
      args_info->ipmRight_orig = 0;
    }
  if (args_info->ipmBottom_orig)
    {
      free (args_info->ipmBottom_orig); /* free previous argument */
      args_info->ipmBottom_orig = 0;
    }
  if (args_info->ipmInterpolation_orig)
    {
      free (args_info->ipmInterpolation_orig); /* free previous argument */
      args_info->ipmInterpolation_orig = 0;
    }
  if (args_info->lineWidth_orig)
    {
      free (args_info->lineWidth_orig); /* free previous argument */
      args_info->lineWidth_orig = 0;
    }
  if (args_info->lineHeight_orig)
    {
      free (args_info->lineHeight_orig); /* free previous argument */
      args_info->lineHeight_orig = 0;
    }
  if (args_info->kernelWidth_orig)
    {
      free (args_info->kernelWidth_orig); /* free previous argument */
      args_info->kernelWidth_orig = 0;
    }
  if (args_info->kernelHeight_orig)
    {
      free (args_info->kernelHeight_orig); /* free previous argument */
      args_info->kernelHeight_orig = 0;
    }
  if (args_info->lowerQuantile_orig)
    {
      free (args_info->lowerQuantile_orig); /* free previous argument */
      args_info->lowerQuantile_orig = 0;
    }
  if (args_info->localMaxima_orig)
    {
      free (args_info->localMaxima_orig); /* free previous argument */
      args_info->localMaxima_orig = 0;
    }
  if (args_info->groupingType_orig)
    {
      free (args_info->groupingType_orig); /* free previous argument */
      args_info->groupingType_orig = 0;
    }
  if (args_info->binarize_orig)
    {
      free (args_info->binarize_orig); /* free previous argument */
      args_info->binarize_orig = 0;
    }
  if (args_info->detectionThreshold_orig)
    {
      free (args_info->detectionThreshold_orig); /* free previous argument */
      args_info->detectionThreshold_orig = 0;
    }
  if (args_info->smoothScores_orig)
    {
      free (args_info->smoothScores_orig); /* free previous argument */
      args_info->smoothScores_orig = 0;
    }
  if (args_info->rMin_orig)
    {
      free (args_info->rMin_orig); /* free previous argument */
      args_info->rMin_orig = 0;
    }
  if (args_info->rMax_orig)
    {
      free (args_info->rMax_orig); /* free previous argument */
      args_info->rMax_orig = 0;
    }
  if (args_info->rStep_orig)
    {
      free (args_info->rStep_orig); /* free previous argument */
      args_info->rStep_orig = 0;
    }
  if (args_info->thetaMin_orig)
    {
      free (args_info->thetaMin_orig); /* free previous argument */
      args_info->thetaMin_orig = 0;
    }
  if (args_info->thetaMax_orig)
    {
      free (args_info->thetaMax_orig); /* free previous argument */
      args_info->thetaMax_orig = 0;
    }
  if (args_info->thetaStep_orig)
    {
      free (args_info->thetaStep_orig); /* free previous argument */
      args_info->thetaStep_orig = 0;
    }
  if (args_info->ipmVpPortion_orig)
    {
      free (args_info->ipmVpPortion_orig); /* free previous argument */
      args_info->ipmVpPortion_orig = 0;
    }
  if (args_info->getEndPoints_orig)
    {
      free (args_info->getEndPoints_orig); /* free previous argument */
      args_info->getEndPoints_orig = 0;
    }
  if (args_info->group_orig)
    {
      free (args_info->group_orig); /* free previous argument */
      args_info->group_orig = 0;
    }
  if (args_info->groupThreshold_orig)
    {
      free (args_info->groupThreshold_orig); /* free previous argument */
      args_info->groupThreshold_orig = 0;
    }
  if (args_info->ransac_orig)
    {
      free (args_info->ransac_orig); /* free previous argument */
      args_info->ransac_orig = 0;
    }
  if (args_info->ransacLineNumSamples_orig)
    {
      free (args_info->ransacLineNumSamples_orig); /* free previous argument */
      args_info->ransacLineNumSamples_orig = 0;
    }
  if (args_info->ransacLineNumIterations_orig)
    {
      free (args_info->ransacLineNumIterations_orig); /* free previous argument */
      args_info->ransacLineNumIterations_orig = 0;
    }
  if (args_info->ransacLineNumGoodFit_orig)
    {
      free (args_info->ransacLineNumGoodFit_orig); /* free previous argument */
      args_info->ransacLineNumGoodFit_orig = 0;
    }
  if (args_info->ransacLineThreshold_orig)
    {
      free (args_info->ransacLineThreshold_orig); /* free previous argument */
      args_info->ransacLineThreshold_orig = 0;
    }
  if (args_info->ransacLineScoreThreshold_orig)
    {
      free (args_info->ransacLineScoreThreshold_orig); /* free previous argument */
      args_info->ransacLineScoreThreshold_orig = 0;
    }
  if (args_info->ransacLineBinarize_orig)
    {
      free (args_info->ransacLineBinarize_orig); /* free previous argument */
      args_info->ransacLineBinarize_orig = 0;
    }
  if (args_info->ransacLineWindow_orig)
    {
      free (args_info->ransacLineWindow_orig); /* free previous argument */
      args_info->ransacLineWindow_orig = 0;
    }
  if (args_info->ransacSplineNumSamples_orig)
    {
      free (args_info->ransacSplineNumSamples_orig); /* free previous argument */
      args_info->ransacSplineNumSamples_orig = 0;
    }
  if (args_info->ransacSplineNumIterations_orig)
    {
      free (args_info->ransacSplineNumIterations_orig); /* free previous argument */
      args_info->ransacSplineNumIterations_orig = 0;
    }
  if (args_info->ransacSplineNumGoodFit_orig)
    {
      free (args_info->ransacSplineNumGoodFit_orig); /* free previous argument */
      args_info->ransacSplineNumGoodFit_orig = 0;
    }
  if (args_info->ransacSplineThreshold_orig)
    {
      free (args_info->ransacSplineThreshold_orig); /* free previous argument */
      args_info->ransacSplineThreshold_orig = 0;
    }
  if (args_info->ransacSplineScoreThreshold_orig)
    {
      free (args_info->ransacSplineScoreThreshold_orig); /* free previous argument */
      args_info->ransacSplineScoreThreshold_orig = 0;
    }
  if (args_info->ransacSplineBinarize_orig)
    {
      free (args_info->ransacSplineBinarize_orig); /* free previous argument */
      args_info->ransacSplineBinarize_orig = 0;
    }
  if (args_info->ransacSplineWindow_orig)
    {
      free (args_info->ransacSplineWindow_orig); /* free previous argument */
      args_info->ransacSplineWindow_orig = 0;
    }
  if (args_info->ransacSplineDegree_orig)
    {
      free (args_info->ransacSplineDegree_orig); /* free previous argument */
      args_info->ransacSplineDegree_orig = 0;
    }
  if (args_info->ransacSpline_orig)
    {
      free (args_info->ransacSpline_orig); /* free previous argument */
      args_info->ransacSpline_orig = 0;
    }
  if (args_info->ransacLine_orig)
    {
      free (args_info->ransacLine_orig); /* free previous argument */
      args_info->ransacLine_orig = 0;
    }
  if (args_info->ransacSplineStep_orig)
    {
      free (args_info->ransacSplineStep_orig); /* free previous argument */
      args_info->ransacSplineStep_orig = 0;
    }
  if (args_info->overlapThreshold_orig)
    {
      free (args_info->overlapThreshold_orig); /* free previous argument */
      args_info->overlapThreshold_orig = 0;
    }
  if (args_info->localizeAngleThreshold_orig)
    {
      free (args_info->localizeAngleThreshold_orig); /* free previous argument */
      args_info->localizeAngleThreshold_orig = 0;
    }
  if (args_info->localizeNumLinePixels_orig)
    {
      free (args_info->localizeNumLinePixels_orig); /* free previous argument */
      args_info->localizeNumLinePixels_orig = 0;
    }
  if (args_info->extendAngleThreshold_orig)
    {
      free (args_info->extendAngleThreshold_orig); /* free previous argument */
      args_info->extendAngleThreshold_orig = 0;
    }
  if (args_info->extendMeanDirAngleThreshold_orig)
    {
      free (args_info->extendMeanDirAngleThreshold_orig); /* free previous argument */
      args_info->extendMeanDirAngleThreshold_orig = 0;
    }
  if (args_info->extendLinePixelsTangent_orig)
    {
      free (args_info->extendLinePixelsTangent_orig); /* free previous argument */
      args_info->extendLinePixelsTangent_orig = 0;
    }
  if (args_info->extendLinePixelsNormal_orig)
    {
      free (args_info->extendLinePixelsNormal_orig); /* free previous argument */
      args_info->extendLinePixelsNormal_orig = 0;
    }
  if (args_info->extendContThreshold_orig)
    {
      free (args_info->extendContThreshold_orig); /* free previous argument */
      args_info->extendContThreshold_orig = 0;
    }
  if (args_info->extendDeviationThreshold_orig)
    {
      free (args_info->extendDeviationThreshold_orig); /* free previous argument */
      args_info->extendDeviationThreshold_orig = 0;
    }
  if (args_info->extendRectTop_orig)
    {
      free (args_info->extendRectTop_orig); /* free previous argument */
      args_info->extendRectTop_orig = 0;
    }
  if (args_info->extendRectBottom_orig)
    {
      free (args_info->extendRectBottom_orig); /* free previous argument */
      args_info->extendRectBottom_orig = 0;
    }
  if (args_info->extendIPMAngleThreshold_orig)
    {
      free (args_info->extendIPMAngleThreshold_orig); /* free previous argument */
      args_info->extendIPMAngleThreshold_orig = 0;
    }
  if (args_info->extendIPMMeanDirAngleThreshold_orig)
    {
      free (args_info->extendIPMMeanDirAngleThreshold_orig); /* free previous argument */
      args_info->extendIPMMeanDirAngleThreshold_orig = 0;
    }
  if (args_info->extendIPMLinePixelsTangent_orig)
    {
      free (args_info->extendIPMLinePixelsTangent_orig); /* free previous argument */
      args_info->extendIPMLinePixelsTangent_orig = 0;
    }
  if (args_info->extendIPMLinePixelsNormal_orig)
    {
      free (args_info->extendIPMLinePixelsNormal_orig); /* free previous argument */
      args_info->extendIPMLinePixelsNormal_orig = 0;
    }
  if (args_info->extendIPMContThreshold_orig)
    {
      free (args_info->extendIPMContThreshold_orig); /* free previous argument */
      args_info->extendIPMContThreshold_orig = 0;
    }
  if (args_info->extendIPMDeviationThreshold_orig)
    {
      free (args_info->extendIPMDeviationThreshold_orig); /* free previous argument */
      args_info->extendIPMDeviationThreshold_orig = 0;
    }
  if (args_info->extendIPMRectTop_orig)
    {
      free (args_info->extendIPMRectTop_orig); /* free previous argument */
      args_info->extendIPMRectTop_orig = 0;
    }
  if (args_info->extendIPMRectBottom_orig)
    {
      free (args_info->extendIPMRectBottom_orig); /* free previous argument */
      args_info->extendIPMRectBottom_orig = 0;
    }
  if (args_info->splineScoreJitter_orig)
    {
      free (args_info->splineScoreJitter_orig); /* free previous argument */
      args_info->splineScoreJitter_orig = 0;
    }
  if (args_info->splineScoreLengthRatio_orig)
    {
      free (args_info->splineScoreLengthRatio_orig); /* free previous argument */
      args_info->splineScoreLengthRatio_orig = 0;
    }
  if (args_info->splineScoreAngleRatio_orig)
    {
      free (args_info->splineScoreAngleRatio_orig); /* free previous argument */
      args_info->splineScoreAngleRatio_orig = 0;
    }
  if (args_info->splineScoreStep_orig)
    {
      free (args_info->splineScoreStep_orig); /* free previous argument */
      args_info->splineScoreStep_orig = 0;
    }
  if (args_info->splineTrackingNumAbsentFrames_orig)
    {
      free (args_info->splineTrackingNumAbsentFrames_orig); /* free previous argument */
      args_info->splineTrackingNumAbsentFrames_orig = 0;
    }
  if (args_info->splineTrackingNumSeenFrames_orig)
    {
      free (args_info->splineTrackingNumSeenFrames_orig); /* free previous argument */
      args_info->splineTrackingNumSeenFrames_orig = 0;
    }
  if (args_info->mergeSplineThetaThreshold_orig)
    {
      free (args_info->mergeSplineThetaThreshold_orig); /* free previous argument */
      args_info->mergeSplineThetaThreshold_orig = 0;
    }
  if (args_info->mergeSplineRThreshold_orig)
    {
      free (args_info->mergeSplineRThreshold_orig); /* free previous argument */
      args_info->mergeSplineRThreshold_orig = 0;
    }
  if (args_info->mergeSplineMeanThetaThreshold_orig)
    {
      free (args_info->mergeSplineMeanThetaThreshold_orig); /* free previous argument */
      args_info->mergeSplineMeanThetaThreshold_orig = 0;
    }
  if (args_info->mergeSplineMeanRThreshold_orig)
    {
      free (args_info->mergeSplineMeanRThreshold_orig); /* free previous argument */
      args_info->mergeSplineMeanRThreshold_orig = 0;
    }
  if (args_info->mergeSplineCentroidThreshold_orig)
    {
      free (args_info->mergeSplineCentroidThreshold_orig); /* free previous argument */
      args_info->mergeSplineCentroidThreshold_orig = 0;
    }
  if (args_info->lineTrackingNumAbsentFrames_orig)
    {
      free (args_info->lineTrackingNumAbsentFrames_orig); /* free previous argument */
      args_info->lineTrackingNumAbsentFrames_orig = 0;
    }
  if (args_info->lineTrackingNumSeenFrames_orig)
    {
      free (args_info->lineTrackingNumSeenFrames_orig); /* free previous argument */
      args_info->lineTrackingNumSeenFrames_orig = 0;
    }
  if (args_info->mergeLineThetaThreshold_orig)
    {
      free (args_info->mergeLineThetaThreshold_orig); /* free previous argument */
      args_info->mergeLineThetaThreshold_orig = 0;
    }
  if (args_info->mergeLineRThreshold_orig)
    {
      free (args_info->mergeLineRThreshold_orig); /* free previous argument */
      args_info->mergeLineRThreshold_orig = 0;
    }
  if (args_info->numStrips_orig)
    {
      free (args_info->numStrips_orig); /* free previous argument */
      args_info->numStrips_orig = 0;
    }
  if (args_info->checkSplines_orig)
    {
      free (args_info->checkSplines_orig); /* free previous argument */
      args_info->checkSplines_orig = 0;
    }
  if (args_info->checkSplinesCurvenessThreshold_orig)
    {
      free (args_info->checkSplinesCurvenessThreshold_orig); /* free previous argument */
      args_info->checkSplinesCurvenessThreshold_orig = 0;
    }
  if (args_info->checkSplinesLengthThreshold_orig)
    {
      free (args_info->checkSplinesLengthThreshold_orig); /* free previous argument */
      args_info->checkSplinesLengthThreshold_orig = 0;
    }
  if (args_info->checkSplinesThetaDiffThreshold_orig)
    {
      free (args_info->checkSplinesThetaDiffThreshold_orig); /* free previous argument */
      args_info->checkSplinesThetaDiffThreshold_orig = 0;
    }
  if (args_info->checkSplinesThetaThreshold_orig)
    {
      free (args_info->checkSplinesThetaThreshold_orig); /* free previous argument */
      args_info->checkSplinesThetaThreshold_orig = 0;
    }
  if (args_info->checkIPMSplines_orig)
    {
      free (args_info->checkIPMSplines_orig); /* free previous argument */
      args_info->checkIPMSplines_orig = 0;
    }
  if (args_info->checkIPMSplinesCurvenessThreshold_orig)
    {
      free (args_info->checkIPMSplinesCurvenessThreshold_orig); /* free previous argument */
      args_info->checkIPMSplinesCurvenessThreshold_orig = 0;
    }
  if (args_info->checkIPMSplinesLengthThreshold_orig)
    {
      free (args_info->checkIPMSplinesLengthThreshold_orig); /* free previous argument */
      args_info->checkIPMSplinesLengthThreshold_orig = 0;
    }
  if (args_info->checkIPMSplinesThetaDiffThreshold_orig)
    {
      free (args_info->checkIPMSplinesThetaDiffThreshold_orig); /* free previous argument */
      args_info->checkIPMSplinesThetaDiffThreshold_orig = 0;
    }
  if (args_info->checkIPMSplinesThetaThreshold_orig)
    {
      free (args_info->checkIPMSplinesThetaThreshold_orig); /* free previous argument */
      args_info->checkIPMSplinesThetaThreshold_orig = 0;
    }
  if (args_info->finalSplineScoreThreshold_orig)
    {
      free (args_info->finalSplineScoreThreshold_orig); /* free previous argument */
      args_info->finalSplineScoreThreshold_orig = 0;
    }
  if (args_info->useGroundPlane_orig)
    {
      free (args_info->useGroundPlane_orig); /* free previous argument */
      args_info->useGroundPlane_orig = 0;
    }
  if (args_info->checkColor_orig)
    {
      free (args_info->checkColor_orig); /* free previous argument */
      args_info->checkColor_orig = 0;
    }
  if (args_info->checkColorWindow_orig)
    {
      free (args_info->checkColorWindow_orig); /* free previous argument */
      args_info->checkColorWindow_orig = 0;
    }
  if (args_info->checkColorNumBins_orig)
    {
      free (args_info->checkColorNumBins_orig); /* free previous argument */
      args_info->checkColorNumBins_orig = 0;
    }
  if (args_info->checkColorNumYellowMin_orig)
    {
      free (args_info->checkColorNumYellowMin_orig); /* free previous argument */
      args_info->checkColorNumYellowMin_orig = 0;
    }
  if (args_info->checkColorRGMin_orig)
    {
      free (args_info->checkColorRGMin_orig); /* free previous argument */
      args_info->checkColorRGMin_orig = 0;
    }
  if (args_info->checkColorRGMax_orig)
    {
      free (args_info->checkColorRGMax_orig); /* free previous argument */
      args_info->checkColorRGMax_orig = 0;
    }
  if (args_info->checkColorGBMin_orig)
    {
      free (args_info->checkColorGBMin_orig); /* free previous argument */
      args_info->checkColorGBMin_orig = 0;
    }
  if (args_info->checkColorRBMin_orig)
    {
      free (args_info->checkColorRBMin_orig); /* free previous argument */
      args_info->checkColorRBMin_orig = 0;
    }
  if (args_info->checkColorRBFThreshold_orig)
    {
      free (args_info->checkColorRBFThreshold_orig); /* free previous argument */
      args_info->checkColorRBFThreshold_orig = 0;
    }
  if (args_info->checkColorRBF_orig)
    {
      free (args_info->checkColorRBF_orig); /* free previous argument */
      args_info->checkColorRBF_orig = 0;
    }
  if (args_info->ipmWindowClear_orig)
    {
      free (args_info->ipmWindowClear_orig); /* free previous argument */
      args_info->ipmWindowClear_orig = 0;
    }
  if (args_info->ipmWindowLeft_orig)
    {
      free (args_info->ipmWindowLeft_orig); /* free previous argument */
      args_info->ipmWindowLeft_orig = 0;
    }
  if (args_info->ipmWindowRight_orig)
    {
      free (args_info->ipmWindowRight_orig); /* free previous argument */
      args_info->ipmWindowRight_orig = 0;
    }
  if (args_info->checkLaneWidth_orig)
    {
      free (args_info->checkLaneWidth_orig); /* free previous argument */
      args_info->checkLaneWidth_orig = 0;
    }
  if (args_info->checkLaneWidthMean_orig)
    {
      free (args_info->checkLaneWidthMean_orig); /* free previous argument */
      args_info->checkLaneWidthMean_orig = 0;
    }
  if (args_info->checkLaneWidthStd_orig)
    {
      free (args_info->checkLaneWidthStd_orig); /* free previous argument */
      args_info->checkLaneWidthStd_orig = 0;
    }

  clear_given (args_info);
}

int
LaneDetectorParser_file_save(const char *filename, struct LaneDetectorParserInfo *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", LANEDETECTORPARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  if (args_info->help_given) {
    fprintf(outfile, "%s\n", "help");
  }
  if (args_info->version_given) {
    fprintf(outfile, "%s\n", "version");
  }
  if (args_info->ipmWidth_given) {
    if (args_info->ipmWidth_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ipmWidth", args_info->ipmWidth_orig);
    } else {
      fprintf(outfile, "%s\n", "ipmWidth");
    }
  }
  if (args_info->ipmHeight_given) {
    if (args_info->ipmHeight_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ipmHeight", args_info->ipmHeight_orig);
    } else {
      fprintf(outfile, "%s\n", "ipmHeight");
    }
  }
  if (args_info->ipmTop_given) {
    if (args_info->ipmTop_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ipmTop", args_info->ipmTop_orig);
    } else {
      fprintf(outfile, "%s\n", "ipmTop");
    }
  }
  if (args_info->ipmLeft_given) {
    if (args_info->ipmLeft_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ipmLeft", args_info->ipmLeft_orig);
    } else {
      fprintf(outfile, "%s\n", "ipmLeft");
    }
  }
  if (args_info->ipmRight_given) {
    if (args_info->ipmRight_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ipmRight", args_info->ipmRight_orig);
    } else {
      fprintf(outfile, "%s\n", "ipmRight");
    }
  }
  if (args_info->ipmBottom_given) {
    if (args_info->ipmBottom_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ipmBottom", args_info->ipmBottom_orig);
    } else {
      fprintf(outfile, "%s\n", "ipmBottom");
    }
  }
  if (args_info->ipmInterpolation_given) {
    if (args_info->ipmInterpolation_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ipmInterpolation", args_info->ipmInterpolation_orig);
    } else {
      fprintf(outfile, "%s\n", "ipmInterpolation");
    }
  }
  if (args_info->lineWidth_given) {
    if (args_info->lineWidth_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "lineWidth", args_info->lineWidth_orig);
    } else {
      fprintf(outfile, "%s\n", "lineWidth");
    }
  }
  if (args_info->lineHeight_given) {
    if (args_info->lineHeight_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "lineHeight", args_info->lineHeight_orig);
    } else {
      fprintf(outfile, "%s\n", "lineHeight");
    }
  }
  if (args_info->kernelWidth_given) {
    if (args_info->kernelWidth_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "kernelWidth", args_info->kernelWidth_orig);
    } else {
      fprintf(outfile, "%s\n", "kernelWidth");
    }
  }
  if (args_info->kernelHeight_given) {
    if (args_info->kernelHeight_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "kernelHeight", args_info->kernelHeight_orig);
    } else {
      fprintf(outfile, "%s\n", "kernelHeight");
    }
  }
  if (args_info->lowerQuantile_given) {
    if (args_info->lowerQuantile_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "lowerQuantile", args_info->lowerQuantile_orig);
    } else {
      fprintf(outfile, "%s\n", "lowerQuantile");
    }
  }
  if (args_info->localMaxima_given) {
    if (args_info->localMaxima_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "localMaxima", args_info->localMaxima_orig);
    } else {
      fprintf(outfile, "%s\n", "localMaxima");
    }
  }
  if (args_info->groupingType_given) {
    if (args_info->groupingType_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "groupingType", args_info->groupingType_orig);
    } else {
      fprintf(outfile, "%s\n", "groupingType");
    }
  }
  if (args_info->binarize_given) {
    if (args_info->binarize_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "binarize", args_info->binarize_orig);
    } else {
      fprintf(outfile, "%s\n", "binarize");
    }
  }
  if (args_info->detectionThreshold_given) {
    if (args_info->detectionThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "detectionThreshold", args_info->detectionThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "detectionThreshold");
    }
  }
  if (args_info->smoothScores_given) {
    if (args_info->smoothScores_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "smoothScores", args_info->smoothScores_orig);
    } else {
      fprintf(outfile, "%s\n", "smoothScores");
    }
  }
  if (args_info->rMin_given) {
    if (args_info->rMin_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "rMin", args_info->rMin_orig);
    } else {
      fprintf(outfile, "%s\n", "rMin");
    }
  }
  if (args_info->rMax_given) {
    if (args_info->rMax_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "rMax", args_info->rMax_orig);
    } else {
      fprintf(outfile, "%s\n", "rMax");
    }
  }
  if (args_info->rStep_given) {
    if (args_info->rStep_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "rStep", args_info->rStep_orig);
    } else {
      fprintf(outfile, "%s\n", "rStep");
    }
  }
  if (args_info->thetaMin_given) {
    if (args_info->thetaMin_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "thetaMin", args_info->thetaMin_orig);
    } else {
      fprintf(outfile, "%s\n", "thetaMin");
    }
  }
  if (args_info->thetaMax_given) {
    if (args_info->thetaMax_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "thetaMax", args_info->thetaMax_orig);
    } else {
      fprintf(outfile, "%s\n", "thetaMax");
    }
  }
  if (args_info->thetaStep_given) {
    if (args_info->thetaStep_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "thetaStep", args_info->thetaStep_orig);
    } else {
      fprintf(outfile, "%s\n", "thetaStep");
    }
  }
  if (args_info->ipmVpPortion_given) {
    if (args_info->ipmVpPortion_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ipmVpPortion", args_info->ipmVpPortion_orig);
    } else {
      fprintf(outfile, "%s\n", "ipmVpPortion");
    }
  }
  if (args_info->getEndPoints_given) {
    if (args_info->getEndPoints_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "getEndPoints", args_info->getEndPoints_orig);
    } else {
      fprintf(outfile, "%s\n", "getEndPoints");
    }
  }
  if (args_info->group_given) {
    if (args_info->group_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "group", args_info->group_orig);
    } else {
      fprintf(outfile, "%s\n", "group");
    }
  }
  if (args_info->groupThreshold_given) {
    if (args_info->groupThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "groupThreshold", args_info->groupThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "groupThreshold");
    }
  }
  if (args_info->ransac_given) {
    if (args_info->ransac_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransac", args_info->ransac_orig);
    } else {
      fprintf(outfile, "%s\n", "ransac");
    }
  }
  if (args_info->ransacLineNumSamples_given) {
    if (args_info->ransacLineNumSamples_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacLineNumSamples", args_info->ransacLineNumSamples_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacLineNumSamples");
    }
  }
  if (args_info->ransacLineNumIterations_given) {
    if (args_info->ransacLineNumIterations_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacLineNumIterations", args_info->ransacLineNumIterations_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacLineNumIterations");
    }
  }
  if (args_info->ransacLineNumGoodFit_given) {
    if (args_info->ransacLineNumGoodFit_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacLineNumGoodFit", args_info->ransacLineNumGoodFit_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacLineNumGoodFit");
    }
  }
  if (args_info->ransacLineThreshold_given) {
    if (args_info->ransacLineThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacLineThreshold", args_info->ransacLineThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacLineThreshold");
    }
  }
  if (args_info->ransacLineScoreThreshold_given) {
    if (args_info->ransacLineScoreThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacLineScoreThreshold", args_info->ransacLineScoreThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacLineScoreThreshold");
    }
  }
  if (args_info->ransacLineBinarize_given) {
    if (args_info->ransacLineBinarize_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacLineBinarize", args_info->ransacLineBinarize_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacLineBinarize");
    }
  }
  if (args_info->ransacLineWindow_given) {
    if (args_info->ransacLineWindow_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacLineWindow", args_info->ransacLineWindow_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacLineWindow");
    }
  }
  if (args_info->ransacSplineNumSamples_given) {
    if (args_info->ransacSplineNumSamples_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacSplineNumSamples", args_info->ransacSplineNumSamples_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacSplineNumSamples");
    }
  }
  if (args_info->ransacSplineNumIterations_given) {
    if (args_info->ransacSplineNumIterations_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacSplineNumIterations", args_info->ransacSplineNumIterations_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacSplineNumIterations");
    }
  }
  if (args_info->ransacSplineNumGoodFit_given) {
    if (args_info->ransacSplineNumGoodFit_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacSplineNumGoodFit", args_info->ransacSplineNumGoodFit_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacSplineNumGoodFit");
    }
  }
  if (args_info->ransacSplineThreshold_given) {
    if (args_info->ransacSplineThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacSplineThreshold", args_info->ransacSplineThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacSplineThreshold");
    }
  }
  if (args_info->ransacSplineScoreThreshold_given) {
    if (args_info->ransacSplineScoreThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacSplineScoreThreshold", args_info->ransacSplineScoreThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacSplineScoreThreshold");
    }
  }
  if (args_info->ransacSplineBinarize_given) {
    if (args_info->ransacSplineBinarize_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacSplineBinarize", args_info->ransacSplineBinarize_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacSplineBinarize");
    }
  }
  if (args_info->ransacSplineWindow_given) {
    if (args_info->ransacSplineWindow_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacSplineWindow", args_info->ransacSplineWindow_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacSplineWindow");
    }
  }
  if (args_info->ransacSplineDegree_given) {
    if (args_info->ransacSplineDegree_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacSplineDegree", args_info->ransacSplineDegree_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacSplineDegree");
    }
  }
  if (args_info->ransacSpline_given) {
    if (args_info->ransacSpline_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacSpline", args_info->ransacSpline_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacSpline");
    }
  }
  if (args_info->ransacLine_given) {
    if (args_info->ransacLine_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacLine", args_info->ransacLine_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacLine");
    }
  }
  if (args_info->ransacSplineStep_given) {
    if (args_info->ransacSplineStep_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ransacSplineStep", args_info->ransacSplineStep_orig);
    } else {
      fprintf(outfile, "%s\n", "ransacSplineStep");
    }
  }
  if (args_info->overlapThreshold_given) {
    if (args_info->overlapThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "overlapThreshold", args_info->overlapThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "overlapThreshold");
    }
  }
  if (args_info->localizeAngleThreshold_given) {
    if (args_info->localizeAngleThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "localizeAngleThreshold", args_info->localizeAngleThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "localizeAngleThreshold");
    }
  }
  if (args_info->localizeNumLinePixels_given) {
    if (args_info->localizeNumLinePixels_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "localizeNumLinePixels", args_info->localizeNumLinePixels_orig);
    } else {
      fprintf(outfile, "%s\n", "localizeNumLinePixels");
    }
  }
  if (args_info->extendAngleThreshold_given) {
    if (args_info->extendAngleThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendAngleThreshold", args_info->extendAngleThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "extendAngleThreshold");
    }
  }
  if (args_info->extendMeanDirAngleThreshold_given) {
    if (args_info->extendMeanDirAngleThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendMeanDirAngleThreshold", args_info->extendMeanDirAngleThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "extendMeanDirAngleThreshold");
    }
  }
  if (args_info->extendLinePixelsTangent_given) {
    if (args_info->extendLinePixelsTangent_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendLinePixelsTangent", args_info->extendLinePixelsTangent_orig);
    } else {
      fprintf(outfile, "%s\n", "extendLinePixelsTangent");
    }
  }
  if (args_info->extendLinePixelsNormal_given) {
    if (args_info->extendLinePixelsNormal_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendLinePixelsNormal", args_info->extendLinePixelsNormal_orig);
    } else {
      fprintf(outfile, "%s\n", "extendLinePixelsNormal");
    }
  }
  if (args_info->extendContThreshold_given) {
    if (args_info->extendContThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendContThreshold", args_info->extendContThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "extendContThreshold");
    }
  }
  if (args_info->extendDeviationThreshold_given) {
    if (args_info->extendDeviationThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendDeviationThreshold", args_info->extendDeviationThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "extendDeviationThreshold");
    }
  }
  if (args_info->extendRectTop_given) {
    if (args_info->extendRectTop_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendRectTop", args_info->extendRectTop_orig);
    } else {
      fprintf(outfile, "%s\n", "extendRectTop");
    }
  }
  if (args_info->extendRectBottom_given) {
    if (args_info->extendRectBottom_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendRectBottom", args_info->extendRectBottom_orig);
    } else {
      fprintf(outfile, "%s\n", "extendRectBottom");
    }
  }
  if (args_info->extendIPMAngleThreshold_given) {
    if (args_info->extendIPMAngleThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendIPMAngleThreshold", args_info->extendIPMAngleThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "extendIPMAngleThreshold");
    }
  }
  if (args_info->extendIPMMeanDirAngleThreshold_given) {
    if (args_info->extendIPMMeanDirAngleThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendIPMMeanDirAngleThreshold", args_info->extendIPMMeanDirAngleThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "extendIPMMeanDirAngleThreshold");
    }
  }
  if (args_info->extendIPMLinePixelsTangent_given) {
    if (args_info->extendIPMLinePixelsTangent_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendIPMLinePixelsTangent", args_info->extendIPMLinePixelsTangent_orig);
    } else {
      fprintf(outfile, "%s\n", "extendIPMLinePixelsTangent");
    }
  }
  if (args_info->extendIPMLinePixelsNormal_given) {
    if (args_info->extendIPMLinePixelsNormal_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendIPMLinePixelsNormal", args_info->extendIPMLinePixelsNormal_orig);
    } else {
      fprintf(outfile, "%s\n", "extendIPMLinePixelsNormal");
    }
  }
  if (args_info->extendIPMContThreshold_given) {
    if (args_info->extendIPMContThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendIPMContThreshold", args_info->extendIPMContThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "extendIPMContThreshold");
    }
  }
  if (args_info->extendIPMDeviationThreshold_given) {
    if (args_info->extendIPMDeviationThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendIPMDeviationThreshold", args_info->extendIPMDeviationThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "extendIPMDeviationThreshold");
    }
  }
  if (args_info->extendIPMRectTop_given) {
    if (args_info->extendIPMRectTop_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendIPMRectTop", args_info->extendIPMRectTop_orig);
    } else {
      fprintf(outfile, "%s\n", "extendIPMRectTop");
    }
  }
  if (args_info->extendIPMRectBottom_given) {
    if (args_info->extendIPMRectBottom_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "extendIPMRectBottom", args_info->extendIPMRectBottom_orig);
    } else {
      fprintf(outfile, "%s\n", "extendIPMRectBottom");
    }
  }
  if (args_info->splineScoreJitter_given) {
    if (args_info->splineScoreJitter_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "splineScoreJitter", args_info->splineScoreJitter_orig);
    } else {
      fprintf(outfile, "%s\n", "splineScoreJitter");
    }
  }
  if (args_info->splineScoreLengthRatio_given) {
    if (args_info->splineScoreLengthRatio_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "splineScoreLengthRatio", args_info->splineScoreLengthRatio_orig);
    } else {
      fprintf(outfile, "%s\n", "splineScoreLengthRatio");
    }
  }
  if (args_info->splineScoreAngleRatio_given) {
    if (args_info->splineScoreAngleRatio_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "splineScoreAngleRatio", args_info->splineScoreAngleRatio_orig);
    } else {
      fprintf(outfile, "%s\n", "splineScoreAngleRatio");
    }
  }
  if (args_info->splineScoreStep_given) {
    if (args_info->splineScoreStep_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "splineScoreStep", args_info->splineScoreStep_orig);
    } else {
      fprintf(outfile, "%s\n", "splineScoreStep");
    }
  }
  if (args_info->splineTrackingNumAbsentFrames_given) {
    if (args_info->splineTrackingNumAbsentFrames_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "splineTrackingNumAbsentFrames", args_info->splineTrackingNumAbsentFrames_orig);
    } else {
      fprintf(outfile, "%s\n", "splineTrackingNumAbsentFrames");
    }
  }
  if (args_info->splineTrackingNumSeenFrames_given) {
    if (args_info->splineTrackingNumSeenFrames_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "splineTrackingNumSeenFrames", args_info->splineTrackingNumSeenFrames_orig);
    } else {
      fprintf(outfile, "%s\n", "splineTrackingNumSeenFrames");
    }
  }
  if (args_info->mergeSplineThetaThreshold_given) {
    if (args_info->mergeSplineThetaThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "mergeSplineThetaThreshold", args_info->mergeSplineThetaThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "mergeSplineThetaThreshold");
    }
  }
  if (args_info->mergeSplineRThreshold_given) {
    if (args_info->mergeSplineRThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "mergeSplineRThreshold", args_info->mergeSplineRThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "mergeSplineRThreshold");
    }
  }
  if (args_info->mergeSplineMeanThetaThreshold_given) {
    if (args_info->mergeSplineMeanThetaThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "mergeSplineMeanThetaThreshold", args_info->mergeSplineMeanThetaThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "mergeSplineMeanThetaThreshold");
    }
  }
  if (args_info->mergeSplineMeanRThreshold_given) {
    if (args_info->mergeSplineMeanRThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "mergeSplineMeanRThreshold", args_info->mergeSplineMeanRThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "mergeSplineMeanRThreshold");
    }
  }
  if (args_info->mergeSplineCentroidThreshold_given) {
    if (args_info->mergeSplineCentroidThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "mergeSplineCentroidThreshold", args_info->mergeSplineCentroidThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "mergeSplineCentroidThreshold");
    }
  }
  if (args_info->lineTrackingNumAbsentFrames_given) {
    if (args_info->lineTrackingNumAbsentFrames_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "lineTrackingNumAbsentFrames", args_info->lineTrackingNumAbsentFrames_orig);
    } else {
      fprintf(outfile, "%s\n", "lineTrackingNumAbsentFrames");
    }
  }
  if (args_info->lineTrackingNumSeenFrames_given) {
    if (args_info->lineTrackingNumSeenFrames_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "lineTrackingNumSeenFrames", args_info->lineTrackingNumSeenFrames_orig);
    } else {
      fprintf(outfile, "%s\n", "lineTrackingNumSeenFrames");
    }
  }
  if (args_info->mergeLineThetaThreshold_given) {
    if (args_info->mergeLineThetaThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "mergeLineThetaThreshold", args_info->mergeLineThetaThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "mergeLineThetaThreshold");
    }
  }
  if (args_info->mergeLineRThreshold_given) {
    if (args_info->mergeLineRThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "mergeLineRThreshold", args_info->mergeLineRThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "mergeLineRThreshold");
    }
  }
  if (args_info->numStrips_given) {
    if (args_info->numStrips_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "numStrips", args_info->numStrips_orig);
    } else {
      fprintf(outfile, "%s\n", "numStrips");
    }
  }
  if (args_info->checkSplines_given) {
    if (args_info->checkSplines_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkSplines", args_info->checkSplines_orig);
    } else {
      fprintf(outfile, "%s\n", "checkSplines");
    }
  }
  if (args_info->checkSplinesCurvenessThreshold_given) {
    if (args_info->checkSplinesCurvenessThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkSplinesCurvenessThreshold", args_info->checkSplinesCurvenessThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "checkSplinesCurvenessThreshold");
    }
  }
  if (args_info->checkSplinesLengthThreshold_given) {
    if (args_info->checkSplinesLengthThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkSplinesLengthThreshold", args_info->checkSplinesLengthThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "checkSplinesLengthThreshold");
    }
  }
  if (args_info->checkSplinesThetaDiffThreshold_given) {
    if (args_info->checkSplinesThetaDiffThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkSplinesThetaDiffThreshold", args_info->checkSplinesThetaDiffThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "checkSplinesThetaDiffThreshold");
    }
  }
  if (args_info->checkSplinesThetaThreshold_given) {
    if (args_info->checkSplinesThetaThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkSplinesThetaThreshold", args_info->checkSplinesThetaThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "checkSplinesThetaThreshold");
    }
  }
  if (args_info->checkIPMSplines_given) {
    if (args_info->checkIPMSplines_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkIPMSplines", args_info->checkIPMSplines_orig);
    } else {
      fprintf(outfile, "%s\n", "checkIPMSplines");
    }
  }
  if (args_info->checkIPMSplinesCurvenessThreshold_given) {
    if (args_info->checkIPMSplinesCurvenessThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkIPMSplinesCurvenessThreshold", args_info->checkIPMSplinesCurvenessThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "checkIPMSplinesCurvenessThreshold");
    }
  }
  if (args_info->checkIPMSplinesLengthThreshold_given) {
    if (args_info->checkIPMSplinesLengthThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkIPMSplinesLengthThreshold", args_info->checkIPMSplinesLengthThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "checkIPMSplinesLengthThreshold");
    }
  }
  if (args_info->checkIPMSplinesThetaDiffThreshold_given) {
    if (args_info->checkIPMSplinesThetaDiffThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkIPMSplinesThetaDiffThreshold", args_info->checkIPMSplinesThetaDiffThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "checkIPMSplinesThetaDiffThreshold");
    }
  }
  if (args_info->checkIPMSplinesThetaThreshold_given) {
    if (args_info->checkIPMSplinesThetaThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkIPMSplinesThetaThreshold", args_info->checkIPMSplinesThetaThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "checkIPMSplinesThetaThreshold");
    }
  }
  if (args_info->finalSplineScoreThreshold_given) {
    if (args_info->finalSplineScoreThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "finalSplineScoreThreshold", args_info->finalSplineScoreThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "finalSplineScoreThreshold");
    }
  }
  if (args_info->useGroundPlane_given) {
    if (args_info->useGroundPlane_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "useGroundPlane", args_info->useGroundPlane_orig);
    } else {
      fprintf(outfile, "%s\n", "useGroundPlane");
    }
  }
  if (args_info->checkColor_given) {
    if (args_info->checkColor_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkColor", args_info->checkColor_orig);
    } else {
      fprintf(outfile, "%s\n", "checkColor");
    }
  }
  if (args_info->checkColorWindow_given) {
    if (args_info->checkColorWindow_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkColorWindow", args_info->checkColorWindow_orig);
    } else {
      fprintf(outfile, "%s\n", "checkColorWindow");
    }
  }
  if (args_info->checkColorNumBins_given) {
    if (args_info->checkColorNumBins_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkColorNumBins", args_info->checkColorNumBins_orig);
    } else {
      fprintf(outfile, "%s\n", "checkColorNumBins");
    }
  }
  if (args_info->checkColorNumYellowMin_given) {
    if (args_info->checkColorNumYellowMin_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkColorNumYellowMin", args_info->checkColorNumYellowMin_orig);
    } else {
      fprintf(outfile, "%s\n", "checkColorNumYellowMin");
    }
  }
  if (args_info->checkColorRGMin_given) {
    if (args_info->checkColorRGMin_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkColorRGMin", args_info->checkColorRGMin_orig);
    } else {
      fprintf(outfile, "%s\n", "checkColorRGMin");
    }
  }
  if (args_info->checkColorRGMax_given) {
    if (args_info->checkColorRGMax_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkColorRGMax", args_info->checkColorRGMax_orig);
    } else {
      fprintf(outfile, "%s\n", "checkColorRGMax");
    }
  }
  if (args_info->checkColorGBMin_given) {
    if (args_info->checkColorGBMin_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkColorGBMin", args_info->checkColorGBMin_orig);
    } else {
      fprintf(outfile, "%s\n", "checkColorGBMin");
    }
  }
  if (args_info->checkColorRBMin_given) {
    if (args_info->checkColorRBMin_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkColorRBMin", args_info->checkColorRBMin_orig);
    } else {
      fprintf(outfile, "%s\n", "checkColorRBMin");
    }
  }
  if (args_info->checkColorRBFThreshold_given) {
    if (args_info->checkColorRBFThreshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkColorRBFThreshold", args_info->checkColorRBFThreshold_orig);
    } else {
      fprintf(outfile, "%s\n", "checkColorRBFThreshold");
    }
  }
  if (args_info->checkColorRBF_given) {
    if (args_info->checkColorRBF_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkColorRBF", args_info->checkColorRBF_orig);
    } else {
      fprintf(outfile, "%s\n", "checkColorRBF");
    }
  }
  if (args_info->ipmWindowClear_given) {
    if (args_info->ipmWindowClear_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ipmWindowClear", args_info->ipmWindowClear_orig);
    } else {
      fprintf(outfile, "%s\n", "ipmWindowClear");
    }
  }
  if (args_info->ipmWindowLeft_given) {
    if (args_info->ipmWindowLeft_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ipmWindowLeft", args_info->ipmWindowLeft_orig);
    } else {
      fprintf(outfile, "%s\n", "ipmWindowLeft");
    }
  }
  if (args_info->ipmWindowRight_given) {
    if (args_info->ipmWindowRight_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "ipmWindowRight", args_info->ipmWindowRight_orig);
    } else {
      fprintf(outfile, "%s\n", "ipmWindowRight");
    }
  }
  if (args_info->checkLaneWidth_given) {
    if (args_info->checkLaneWidth_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkLaneWidth", args_info->checkLaneWidth_orig);
    } else {
      fprintf(outfile, "%s\n", "checkLaneWidth");
    }
  }
  if (args_info->checkLaneWidthMean_given) {
    if (args_info->checkLaneWidthMean_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkLaneWidthMean", args_info->checkLaneWidthMean_orig);
    } else {
      fprintf(outfile, "%s\n", "checkLaneWidthMean");
    }
  }
  if (args_info->checkLaneWidthStd_given) {
    if (args_info->checkLaneWidthStd_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "checkLaneWidthStd", args_info->checkLaneWidthStd_orig);
    } else {
      fprintf(outfile, "%s\n", "checkLaneWidthStd");
    }
  }

  fclose (outfile);

  i = EXIT_SUCCESS;
  return i;
}

void
LaneDetectorParser_free (struct LaneDetectorParserInfo *args_info)
{
  LaneDetectorParser_release (args_info);
}


/* gengetopt_strdup() */
/* strdup.c replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = NULL;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
LaneDetectorParser (int argc, char * const *argv, struct LaneDetectorParserInfo *args_info)
{
  return LaneDetectorParser2 (argc, argv, args_info, 0, 1, 1);
}

int
LaneDetectorParser2 (int argc, char * const *argv, struct LaneDetectorParserInfo *args_info, int override, int initialize, int check_required)
{
  int result;

  result = LaneDetectorParser_internal (argc, argv, args_info, override, initialize, check_required, NULL);

  if (result == EXIT_FAILURE)
    {
      LaneDetectorParser_free (args_info);
      exit (EXIT_FAILURE);
    }

  return result;
}

int
LaneDetectorParser_required (struct LaneDetectorParserInfo *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (LaneDetectorParser_required2(args_info, prog_name, NULL) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      LaneDetectorParser_free (args_info);
      exit (EXIT_FAILURE);
    }

  return result;
}

int
LaneDetectorParser_required2 (struct LaneDetectorParserInfo *args_info, const char *prog_name, const char *additional_error)
{
  int error = 0;

  /* checks for required options */
  if (! args_info->ipmWidth_given)
    {
      fprintf (stderr, "%s: '--ipmWidth' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ipmHeight_given)
    {
      fprintf (stderr, "%s: '--ipmHeight' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ipmTop_given)
    {
      fprintf (stderr, "%s: '--ipmTop' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ipmLeft_given)
    {
      fprintf (stderr, "%s: '--ipmLeft' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ipmRight_given)
    {
      fprintf (stderr, "%s: '--ipmRight' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ipmBottom_given)
    {
      fprintf (stderr, "%s: '--ipmBottom' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ipmInterpolation_given)
    {
      fprintf (stderr, "%s: '--ipmInterpolation' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->lineWidth_given)
    {
      fprintf (stderr, "%s: '--lineWidth' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->lineHeight_given)
    {
      fprintf (stderr, "%s: '--lineHeight' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->kernelWidth_given)
    {
      fprintf (stderr, "%s: '--kernelWidth' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->kernelHeight_given)
    {
      fprintf (stderr, "%s: '--kernelHeight' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->lowerQuantile_given)
    {
      fprintf (stderr, "%s: '--lowerQuantile' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->localMaxima_given)
    {
      fprintf (stderr, "%s: '--localMaxima' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->groupingType_given)
    {
      fprintf (stderr, "%s: '--groupingType' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->binarize_given)
    {
      fprintf (stderr, "%s: '--binarize' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->detectionThreshold_given)
    {
      fprintf (stderr, "%s: '--detectionThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->smoothScores_given)
    {
      fprintf (stderr, "%s: '--smoothScores' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->rMin_given)
    {
      fprintf (stderr, "%s: '--rMin' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->rMax_given)
    {
      fprintf (stderr, "%s: '--rMax' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->rStep_given)
    {
      fprintf (stderr, "%s: '--rStep' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->thetaMin_given)
    {
      fprintf (stderr, "%s: '--thetaMin' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->thetaMax_given)
    {
      fprintf (stderr, "%s: '--thetaMax' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->thetaStep_given)
    {
      fprintf (stderr, "%s: '--thetaStep' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ipmVpPortion_given)
    {
      fprintf (stderr, "%s: '--ipmVpPortion' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->getEndPoints_given)
    {
      fprintf (stderr, "%s: '--getEndPoints' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->group_given)
    {
      fprintf (stderr, "%s: '--group' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->groupThreshold_given)
    {
      fprintf (stderr, "%s: '--groupThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransac_given)
    {
      fprintf (stderr, "%s: '--ransac' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacLineNumSamples_given)
    {
      fprintf (stderr, "%s: '--ransacLineNumSamples' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacLineNumIterations_given)
    {
      fprintf (stderr, "%s: '--ransacLineNumIterations' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacLineNumGoodFit_given)
    {
      fprintf (stderr, "%s: '--ransacLineNumGoodFit' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacLineThreshold_given)
    {
      fprintf (stderr, "%s: '--ransacLineThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacLineScoreThreshold_given)
    {
      fprintf (stderr, "%s: '--ransacLineScoreThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacLineBinarize_given)
    {
      fprintf (stderr, "%s: '--ransacLineBinarize' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacLineWindow_given)
    {
      fprintf (stderr, "%s: '--ransacLineWindow' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacSplineNumSamples_given)
    {
      fprintf (stderr, "%s: '--ransacSplineNumSamples' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacSplineNumIterations_given)
    {
      fprintf (stderr, "%s: '--ransacSplineNumIterations' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacSplineNumGoodFit_given)
    {
      fprintf (stderr, "%s: '--ransacSplineNumGoodFit' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacSplineThreshold_given)
    {
      fprintf (stderr, "%s: '--ransacSplineThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacSplineScoreThreshold_given)
    {
      fprintf (stderr, "%s: '--ransacSplineScoreThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacSplineBinarize_given)
    {
      fprintf (stderr, "%s: '--ransacSplineBinarize' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacSplineWindow_given)
    {
      fprintf (stderr, "%s: '--ransacSplineWindow' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacSplineDegree_given)
    {
      fprintf (stderr, "%s: '--ransacSplineDegree' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacSpline_given)
    {
      fprintf (stderr, "%s: '--ransacSpline' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacLine_given)
    {
      fprintf (stderr, "%s: '--ransacLine' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ransacSplineStep_given)
    {
      fprintf (stderr, "%s: '--ransacSplineStep' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->overlapThreshold_given)
    {
      fprintf (stderr, "%s: '--overlapThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->localizeAngleThreshold_given)
    {
      fprintf (stderr, "%s: '--localizeAngleThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->localizeNumLinePixels_given)
    {
      fprintf (stderr, "%s: '--localizeNumLinePixels' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendAngleThreshold_given)
    {
      fprintf (stderr, "%s: '--extendAngleThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendMeanDirAngleThreshold_given)
    {
      fprintf (stderr, "%s: '--extendMeanDirAngleThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendLinePixelsTangent_given)
    {
      fprintf (stderr, "%s: '--extendLinePixelsTangent' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendLinePixelsNormal_given)
    {
      fprintf (stderr, "%s: '--extendLinePixelsNormal' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendContThreshold_given)
    {
      fprintf (stderr, "%s: '--extendContThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendDeviationThreshold_given)
    {
      fprintf (stderr, "%s: '--extendDeviationThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendRectTop_given)
    {
      fprintf (stderr, "%s: '--extendRectTop' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendRectBottom_given)
    {
      fprintf (stderr, "%s: '--extendRectBottom' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendIPMAngleThreshold_given)
    {
      fprintf (stderr, "%s: '--extendIPMAngleThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendIPMMeanDirAngleThreshold_given)
    {
      fprintf (stderr, "%s: '--extendIPMMeanDirAngleThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendIPMLinePixelsTangent_given)
    {
      fprintf (stderr, "%s: '--extendIPMLinePixelsTangent' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendIPMLinePixelsNormal_given)
    {
      fprintf (stderr, "%s: '--extendIPMLinePixelsNormal' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendIPMContThreshold_given)
    {
      fprintf (stderr, "%s: '--extendIPMContThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendIPMDeviationThreshold_given)
    {
      fprintf (stderr, "%s: '--extendIPMDeviationThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendIPMRectTop_given)
    {
      fprintf (stderr, "%s: '--extendIPMRectTop' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->extendIPMRectBottom_given)
    {
      fprintf (stderr, "%s: '--extendIPMRectBottom' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->splineScoreJitter_given)
    {
      fprintf (stderr, "%s: '--splineScoreJitter' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->splineScoreLengthRatio_given)
    {
      fprintf (stderr, "%s: '--splineScoreLengthRatio' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->splineScoreAngleRatio_given)
    {
      fprintf (stderr, "%s: '--splineScoreAngleRatio' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->splineScoreStep_given)
    {
      fprintf (stderr, "%s: '--splineScoreStep' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->splineTrackingNumAbsentFrames_given)
    {
      fprintf (stderr, "%s: '--splineTrackingNumAbsentFrames' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->splineTrackingNumSeenFrames_given)
    {
      fprintf (stderr, "%s: '--splineTrackingNumSeenFrames' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->mergeSplineThetaThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeSplineThetaThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->mergeSplineRThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeSplineRThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->mergeSplineMeanThetaThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeSplineMeanThetaThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->mergeSplineMeanRThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeSplineMeanRThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->mergeSplineCentroidThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeSplineCentroidThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->lineTrackingNumAbsentFrames_given)
    {
      fprintf (stderr, "%s: '--lineTrackingNumAbsentFrames' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->lineTrackingNumSeenFrames_given)
    {
      fprintf (stderr, "%s: '--lineTrackingNumSeenFrames' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->mergeLineThetaThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeLineThetaThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->mergeLineRThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeLineRThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->numStrips_given)
    {
      fprintf (stderr, "%s: '--numStrips' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkSplines_given)
    {
      fprintf (stderr, "%s: '--checkSplines' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkSplinesCurvenessThreshold_given)
    {
      fprintf (stderr, "%s: '--checkSplinesCurvenessThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkSplinesLengthThreshold_given)
    {
      fprintf (stderr, "%s: '--checkSplinesLengthThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkSplinesThetaDiffThreshold_given)
    {
      fprintf (stderr, "%s: '--checkSplinesThetaDiffThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkSplinesThetaThreshold_given)
    {
      fprintf (stderr, "%s: '--checkSplinesThetaThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkIPMSplines_given)
    {
      fprintf (stderr, "%s: '--checkIPMSplines' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkIPMSplinesCurvenessThreshold_given)
    {
      fprintf (stderr, "%s: '--checkIPMSplinesCurvenessThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkIPMSplinesLengthThreshold_given)
    {
      fprintf (stderr, "%s: '--checkIPMSplinesLengthThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkIPMSplinesThetaDiffThreshold_given)
    {
      fprintf (stderr, "%s: '--checkIPMSplinesThetaDiffThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkIPMSplinesThetaThreshold_given)
    {
      fprintf (stderr, "%s: '--checkIPMSplinesThetaThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->finalSplineScoreThreshold_given)
    {
      fprintf (stderr, "%s: '--finalSplineScoreThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->useGroundPlane_given)
    {
      fprintf (stderr, "%s: '--useGroundPlane' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkColor_given)
    {
      fprintf (stderr, "%s: '--checkColor' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkColorWindow_given)
    {
      fprintf (stderr, "%s: '--checkColorWindow' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkColorNumBins_given)
    {
      fprintf (stderr, "%s: '--checkColorNumBins' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkColorNumYellowMin_given)
    {
      fprintf (stderr, "%s: '--checkColorNumYellowMin' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkColorRGMin_given)
    {
      fprintf (stderr, "%s: '--checkColorRGMin' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkColorRGMax_given)
    {
      fprintf (stderr, "%s: '--checkColorRGMax' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkColorGBMin_given)
    {
      fprintf (stderr, "%s: '--checkColorGBMin' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkColorRBMin_given)
    {
      fprintf (stderr, "%s: '--checkColorRBMin' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkColorRBFThreshold_given)
    {
      fprintf (stderr, "%s: '--checkColorRBFThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkColorRBF_given)
    {
      fprintf (stderr, "%s: '--checkColorRBF' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ipmWindowClear_given)
    {
      fprintf (stderr, "%s: '--ipmWindowClear' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ipmWindowLeft_given)
    {
      fprintf (stderr, "%s: '--ipmWindowLeft' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->ipmWindowRight_given)
    {
      fprintf (stderr, "%s: '--ipmWindowRight' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkLaneWidth_given)
    {
      fprintf (stderr, "%s: '--checkLaneWidth' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkLaneWidthMean_given)
    {
      fprintf (stderr, "%s: '--checkLaneWidthMean' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }

  if (! args_info->checkLaneWidthStd_given)
    {
      fprintf (stderr, "%s: '--checkLaneWidthStd' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }


  /* checks for dependences among options */

  return error;
}

int
LaneDetectorParser_internal (int argc, char * const *argv, struct LaneDetectorParserInfo *args_info, int override, int initialize, int check_required, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error = 0;
  struct LaneDetectorParserInfo local_args_info;

  if (initialize)
    LaneDetectorParser_init (args_info);

  LaneDetectorParser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = 1;
  optopt = '?';

  while (1)
    {
      int option_index = 0;
      char *stop_char;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "ipmWidth",	1, NULL, 0 },
        { "ipmHeight",	1, NULL, 0 },
        { "ipmTop",	1, NULL, 0 },
        { "ipmLeft",	1, NULL, 0 },
        { "ipmRight",	1, NULL, 0 },
        { "ipmBottom",	1, NULL, 0 },
        { "ipmInterpolation",	1, NULL, 0 },
        { "lineWidth",	1, NULL, 0 },
        { "lineHeight",	1, NULL, 0 },
        { "kernelWidth",	1, NULL, 0 },
        { "kernelHeight",	1, NULL, 0 },
        { "lowerQuantile",	1, NULL, 0 },
        { "localMaxima",	1, NULL, 0 },
        { "groupingType",	1, NULL, 0 },
        { "binarize",	1, NULL, 0 },
        { "detectionThreshold",	1, NULL, 0 },
        { "smoothScores",	1, NULL, 0 },
        { "rMin",	1, NULL, 0 },
        { "rMax",	1, NULL, 0 },
        { "rStep",	1, NULL, 0 },
        { "thetaMin",	1, NULL, 0 },
        { "thetaMax",	1, NULL, 0 },
        { "thetaStep",	1, NULL, 0 },
        { "ipmVpPortion",	1, NULL, 0 },
        { "getEndPoints",	1, NULL, 0 },
        { "group",	1, NULL, 0 },
        { "groupThreshold",	1, NULL, 0 },
        { "ransac",	1, NULL, 0 },
        { "ransacLineNumSamples",	1, NULL, 0 },
        { "ransacLineNumIterations",	1, NULL, 0 },
        { "ransacLineNumGoodFit",	1, NULL, 0 },
        { "ransacLineThreshold",	1, NULL, 0 },
        { "ransacLineScoreThreshold",	1, NULL, 0 },
        { "ransacLineBinarize",	1, NULL, 0 },
        { "ransacLineWindow",	1, NULL, 0 },
        { "ransacSplineNumSamples",	1, NULL, 0 },
        { "ransacSplineNumIterations",	1, NULL, 0 },
        { "ransacSplineNumGoodFit",	1, NULL, 0 },
        { "ransacSplineThreshold",	1, NULL, 0 },
        { "ransacSplineScoreThreshold",	1, NULL, 0 },
        { "ransacSplineBinarize",	1, NULL, 0 },
        { "ransacSplineWindow",	1, NULL, 0 },
        { "ransacSplineDegree",	1, NULL, 0 },
        { "ransacSpline",	1, NULL, 0 },
        { "ransacLine",	1, NULL, 0 },
        { "ransacSplineStep",	1, NULL, 0 },
        { "overlapThreshold",	1, NULL, 0 },
        { "localizeAngleThreshold",	1, NULL, 0 },
        { "localizeNumLinePixels",	1, NULL, 0 },
        { "extendAngleThreshold",	1, NULL, 0 },
        { "extendMeanDirAngleThreshold",	1, NULL, 0 },
        { "extendLinePixelsTangent",	1, NULL, 0 },
        { "extendLinePixelsNormal",	1, NULL, 0 },
        { "extendContThreshold",	1, NULL, 0 },
        { "extendDeviationThreshold",	1, NULL, 0 },
        { "extendRectTop",	1, NULL, 0 },
        { "extendRectBottom",	1, NULL, 0 },
        { "extendIPMAngleThreshold",	1, NULL, 0 },
        { "extendIPMMeanDirAngleThreshold",	1, NULL, 0 },
        { "extendIPMLinePixelsTangent",	1, NULL, 0 },
        { "extendIPMLinePixelsNormal",	1, NULL, 0 },
        { "extendIPMContThreshold",	1, NULL, 0 },
        { "extendIPMDeviationThreshold",	1, NULL, 0 },
        { "extendIPMRectTop",	1, NULL, 0 },
        { "extendIPMRectBottom",	1, NULL, 0 },
        { "splineScoreJitter",	1, NULL, 0 },
        { "splineScoreLengthRatio",	1, NULL, 0 },
        { "splineScoreAngleRatio",	1, NULL, 0 },
        { "splineScoreStep",	1, NULL, 0 },
        { "splineTrackingNumAbsentFrames",	1, NULL, 0 },
        { "splineTrackingNumSeenFrames",	1, NULL, 0 },
        { "mergeSplineThetaThreshold",	1, NULL, 0 },
        { "mergeSplineRThreshold",	1, NULL, 0 },
        { "mergeSplineMeanThetaThreshold",	1, NULL, 0 },
        { "mergeSplineMeanRThreshold",	1, NULL, 0 },
        { "mergeSplineCentroidThreshold",	1, NULL, 0 },
        { "lineTrackingNumAbsentFrames",	1, NULL, 0 },
        { "lineTrackingNumSeenFrames",	1, NULL, 0 },
        { "mergeLineThetaThreshold",	1, NULL, 0 },
        { "mergeLineRThreshold",	1, NULL, 0 },
        { "numStrips",	1, NULL, 0 },
        { "checkSplines",	1, NULL, 0 },
        { "checkSplinesCurvenessThreshold",	1, NULL, 0 },
        { "checkSplinesLengthThreshold",	1, NULL, 0 },
        { "checkSplinesThetaDiffThreshold",	1, NULL, 0 },
        { "checkSplinesThetaThreshold",	1, NULL, 0 },
        { "checkIPMSplines",	1, NULL, 0 },
        { "checkIPMSplinesCurvenessThreshold",	1, NULL, 0 },
        { "checkIPMSplinesLengthThreshold",	1, NULL, 0 },
        { "checkIPMSplinesThetaDiffThreshold",	1, NULL, 0 },
        { "checkIPMSplinesThetaThreshold",	1, NULL, 0 },
        { "finalSplineScoreThreshold",	1, NULL, 0 },
        { "useGroundPlane",	1, NULL, 0 },
        { "checkColor",	1, NULL, 0 },
        { "checkColorWindow",	1, NULL, 0 },
        { "checkColorNumBins",	1, NULL, 0 },
        { "checkColorNumYellowMin",	1, NULL, 0 },
        { "checkColorRGMin",	1, NULL, 0 },
        { "checkColorRGMax",	1, NULL, 0 },
        { "checkColorGBMin",	1, NULL, 0 },
        { "checkColorRBMin",	1, NULL, 0 },
        { "checkColorRBFThreshold",	1, NULL, 0 },
        { "checkColorRBF",	1, NULL, 0 },
        { "ipmWindowClear",	1, NULL, 0 },
        { "ipmWindowLeft",	1, NULL, 0 },
        { "ipmWindowRight",	1, NULL, 0 },
        { "checkLaneWidth",	1, NULL, 0 },
        { "checkLaneWidthMean",	1, NULL, 0 },
        { "checkLaneWidthStd",	1, NULL, 0 },
        { NULL,	0, NULL, 0 }
      };

      stop_char = 0;
      c = getopt_long (argc, argv, "hV", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          LaneDetectorParser_print_help ();
          LaneDetectorParser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          LaneDetectorParser_print_version ();
          LaneDetectorParser_free (&local_args_info);
          exit (EXIT_SUCCESS);


        case 0:	/* Long option with no short option */
          /* width of IPM image to use.  */
          if (strcmp (long_options[option_index].name, "ipmWidth") == 0)
          {
            if (local_args_info.ipmWidth_given)
              {
                fprintf (stderr, "%s: `--ipmWidth' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ipmWidth_given && ! override)
              continue;
            local_args_info.ipmWidth_given = 1;
            args_info->ipmWidth_given = 1;
            args_info->ipmWidth_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ipmWidth_orig)
              free (args_info->ipmWidth_orig); /* free previous string */
            args_info->ipmWidth_orig = gengetopt_strdup (optarg);
          }
          /* height of IPM image to use.  */
          else if (strcmp (long_options[option_index].name, "ipmHeight") == 0)
          {
            if (local_args_info.ipmHeight_given)
              {
                fprintf (stderr, "%s: `--ipmHeight' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ipmHeight_given && ! override)
              continue;
            local_args_info.ipmHeight_given = 1;
            args_info->ipmHeight_given = 1;
            args_info->ipmHeight_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ipmHeight_orig)
              free (args_info->ipmHeight_orig); /* free previous string */
            args_info->ipmHeight_orig = gengetopt_strdup (optarg);
          }
          /* Top point in original image of region to make IPM for.  */
          else if (strcmp (long_options[option_index].name, "ipmTop") == 0)
          {
            if (local_args_info.ipmTop_given)
              {
                fprintf (stderr, "%s: `--ipmTop' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ipmTop_given && ! override)
              continue;
            local_args_info.ipmTop_given = 1;
            args_info->ipmTop_given = 1;
            args_info->ipmTop_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ipmTop_orig)
              free (args_info->ipmTop_orig); /* free previous string */
            args_info->ipmTop_orig = gengetopt_strdup (optarg);
          }
          /* Left point in original image of region to make IPM for.  */
          else if (strcmp (long_options[option_index].name, "ipmLeft") == 0)
          {
            if (local_args_info.ipmLeft_given)
              {
                fprintf (stderr, "%s: `--ipmLeft' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ipmLeft_given && ! override)
              continue;
            local_args_info.ipmLeft_given = 1;
            args_info->ipmLeft_given = 1;
            args_info->ipmLeft_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ipmLeft_orig)
              free (args_info->ipmLeft_orig); /* free previous string */
            args_info->ipmLeft_orig = gengetopt_strdup (optarg);
          }
          /* Right point in original image region to make IPM for.  */
          else if (strcmp (long_options[option_index].name, "ipmRight") == 0)
          {
            if (local_args_info.ipmRight_given)
              {
                fprintf (stderr, "%s: `--ipmRight' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ipmRight_given && ! override)
              continue;
            local_args_info.ipmRight_given = 1;
            args_info->ipmRight_given = 1;
            args_info->ipmRight_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ipmRight_orig)
              free (args_info->ipmRight_orig); /* free previous string */
            args_info->ipmRight_orig = gengetopt_strdup (optarg);
          }
          /* Bottom point in original image region to make IPM for.  */
          else if (strcmp (long_options[option_index].name, "ipmBottom") == 0)
          {
            if (local_args_info.ipmBottom_given)
              {
                fprintf (stderr, "%s: `--ipmBottom' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ipmBottom_given && ! override)
              continue;
            local_args_info.ipmBottom_given = 1;
            args_info->ipmBottom_given = 1;
            args_info->ipmBottom_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ipmBottom_orig)
              free (args_info->ipmBottom_orig); /* free previous string */
            args_info->ipmBottom_orig = gengetopt_strdup (optarg);
          }
          /* The method to use for IPM interpolation.  */
          else if (strcmp (long_options[option_index].name, "ipmInterpolation") == 0)
          {
            if (local_args_info.ipmInterpolation_given)
              {
                fprintf (stderr, "%s: `--ipmInterpolation' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ipmInterpolation_given && ! override)
              continue;
            local_args_info.ipmInterpolation_given = 1;
            args_info->ipmInterpolation_given = 1;
            args_info->ipmInterpolation_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ipmInterpolation_orig)
              free (args_info->ipmInterpolation_orig); /* free previous string */
            args_info->ipmInterpolation_orig = gengetopt_strdup (optarg);
          }
          /* width of line to detect in mm (in the world).  */
          else if (strcmp (long_options[option_index].name, "lineWidth") == 0)
          {
            if (local_args_info.lineWidth_given)
              {
                fprintf (stderr, "%s: `--lineWidth' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->lineWidth_given && ! override)
              continue;
            local_args_info.lineWidth_given = 1;
            args_info->lineWidth_given = 1;
            args_info->lineWidth_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->lineWidth_orig)
              free (args_info->lineWidth_orig); /* free previous string */
            args_info->lineWidth_orig = gengetopt_strdup (optarg);
          }
          /* height of line to detect in mm (in the world).  */
          else if (strcmp (long_options[option_index].name, "lineHeight") == 0)
          {
            if (local_args_info.lineHeight_given)
              {
                fprintf (stderr, "%s: `--lineHeight' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->lineHeight_given && ! override)
              continue;
            local_args_info.lineHeight_given = 1;
            args_info->lineHeight_given = 1;
            args_info->lineHeight_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->lineHeight_orig)
              free (args_info->lineHeight_orig); /* free previous string */
            args_info->lineHeight_orig = gengetopt_strdup (optarg);
          }
          /* widht of kernel to use for filtering.  */
          else if (strcmp (long_options[option_index].name, "kernelWidth") == 0)
          {
            if (local_args_info.kernelWidth_given)
              {
                fprintf (stderr, "%s: `--kernelWidth' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->kernelWidth_given && ! override)
              continue;
            local_args_info.kernelWidth_given = 1;
            args_info->kernelWidth_given = 1;
            args_info->kernelWidth_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->kernelWidth_orig)
              free (args_info->kernelWidth_orig); /* free previous string */
            args_info->kernelWidth_orig = gengetopt_strdup (optarg);
          }
          /* Height of kernel to use for filtering.  */
          else if (strcmp (long_options[option_index].name, "kernelHeight") == 0)
          {
            if (local_args_info.kernelHeight_given)
              {
                fprintf (stderr, "%s: `--kernelHeight' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->kernelHeight_given && ! override)
              continue;
            local_args_info.kernelHeight_given = 1;
            args_info->kernelHeight_given = 1;
            args_info->kernelHeight_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->kernelHeight_orig)
              free (args_info->kernelHeight_orig); /* free previous string */
            args_info->kernelHeight_orig = gengetopt_strdup (optarg);
          }
          /* lower quantile to use for thresholding the filtered image.  */
          else if (strcmp (long_options[option_index].name, "lowerQuantile") == 0)
          {
            if (local_args_info.lowerQuantile_given)
              {
                fprintf (stderr, "%s: `--lowerQuantile' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->lowerQuantile_given && ! override)
              continue;
            local_args_info.lowerQuantile_given = 1;
            args_info->lowerQuantile_given = 1;
            args_info->lowerQuantile_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->lowerQuantile_orig)
              free (args_info->lowerQuantile_orig); /* free previous string */
            args_info->lowerQuantile_orig = gengetopt_strdup (optarg);
          }
          /* whether to return local maxima or just the maximum.  */
          else if (strcmp (long_options[option_index].name, "localMaxima") == 0)
          {
            if (local_args_info.localMaxima_given)
              {
                fprintf (stderr, "%s: `--localMaxima' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->localMaxima_given && ! override)
              continue;
            local_args_info.localMaxima_given = 1;
            args_info->localMaxima_given = 1;
            args_info->localMaxima_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->localMaxima_orig)
              free (args_info->localMaxima_orig); /* free previous string */
            args_info->localMaxima_orig = gengetopt_strdup (optarg);
          }
          /* type of grouping to use (default 0: HV lines).  */
          else if (strcmp (long_options[option_index].name, "groupingType") == 0)
          {
            if (local_args_info.groupingType_given)
              {
                fprintf (stderr, "%s: `--groupingType' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->groupingType_given && ! override)
              continue;
            local_args_info.groupingType_given = 1;
            args_info->groupingType_given = 1;
            args_info->groupingType_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->groupingType_orig)
              free (args_info->groupingType_orig); /* free previous string */
            args_info->groupingType_orig = gengetopt_strdup (optarg);
          }
          /* whether to binarize the thresholded image or use the raw values.  */
          else if (strcmp (long_options[option_index].name, "binarize") == 0)
          {
            if (local_args_info.binarize_given)
              {
                fprintf (stderr, "%s: `--binarize' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->binarize_given && ! override)
              continue;
            local_args_info.binarize_given = 1;
            args_info->binarize_given = 1;
            args_info->binarize_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->binarize_orig)
              free (args_info->binarize_orig); /* free previous string */
            args_info->binarize_orig = gengetopt_strdup (optarg);
          }
          /* threshold for line scores to declare as line.  */
          else if (strcmp (long_options[option_index].name, "detectionThreshold") == 0)
          {
            if (local_args_info.detectionThreshold_given)
              {
                fprintf (stderr, "%s: `--detectionThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->detectionThreshold_given && ! override)
              continue;
            local_args_info.detectionThreshold_given = 1;
            args_info->detectionThreshold_given = 1;
            args_info->detectionThreshold_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->detectionThreshold_orig)
              free (args_info->detectionThreshold_orig); /* free previous string */
            args_info->detectionThreshold_orig = gengetopt_strdup (optarg);
          }
          /* whether to smooth scores of lines detected or not.  */
          else if (strcmp (long_options[option_index].name, "smoothScores") == 0)
          {
            if (local_args_info.smoothScores_given)
              {
                fprintf (stderr, "%s: `--smoothScores' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->smoothScores_given && ! override)
              continue;
            local_args_info.smoothScores_given = 1;
            args_info->smoothScores_given = 1;
            args_info->smoothScores_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->smoothScores_orig)
              free (args_info->smoothScores_orig); /* free previous string */
            args_info->smoothScores_orig = gengetopt_strdup (optarg);
          }
          /* rMin for Hough transform (in pixels).  */
          else if (strcmp (long_options[option_index].name, "rMin") == 0)
          {
            if (local_args_info.rMin_given)
              {
                fprintf (stderr, "%s: `--rMin' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->rMin_given && ! override)
              continue;
            local_args_info.rMin_given = 1;
            args_info->rMin_given = 1;
            args_info->rMin_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->rMin_orig)
              free (args_info->rMin_orig); /* free previous string */
            args_info->rMin_orig = gengetopt_strdup (optarg);
          }
          /* rMax for Hough transform (in pixels).  */
          else if (strcmp (long_options[option_index].name, "rMax") == 0)
          {
            if (local_args_info.rMax_given)
              {
                fprintf (stderr, "%s: `--rMax' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->rMax_given && ! override)
              continue;
            local_args_info.rMax_given = 1;
            args_info->rMax_given = 1;
            args_info->rMax_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->rMax_orig)
              free (args_info->rMax_orig); /* free previous string */
            args_info->rMax_orig = gengetopt_strdup (optarg);
          }
          /* rStep for Hough transform (in pixels).  */
          else if (strcmp (long_options[option_index].name, "rStep") == 0)
          {
            if (local_args_info.rStep_given)
              {
                fprintf (stderr, "%s: `--rStep' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->rStep_given && ! override)
              continue;
            local_args_info.rStep_given = 1;
            args_info->rStep_given = 1;
            args_info->rStep_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->rStep_orig)
              free (args_info->rStep_orig); /* free previous string */
            args_info->rStep_orig = gengetopt_strdup (optarg);
          }
          /* thetaMin for Hough transform (in degrees).  */
          else if (strcmp (long_options[option_index].name, "thetaMin") == 0)
          {
            if (local_args_info.thetaMin_given)
              {
                fprintf (stderr, "%s: `--thetaMin' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->thetaMin_given && ! override)
              continue;
            local_args_info.thetaMin_given = 1;
            args_info->thetaMin_given = 1;
            args_info->thetaMin_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->thetaMin_orig)
              free (args_info->thetaMin_orig); /* free previous string */
            args_info->thetaMin_orig = gengetopt_strdup (optarg);
          }
          /* thetaMax for Hough transform (in degrees).  */
          else if (strcmp (long_options[option_index].name, "thetaMax") == 0)
          {
            if (local_args_info.thetaMax_given)
              {
                fprintf (stderr, "%s: `--thetaMax' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->thetaMax_given && ! override)
              continue;
            local_args_info.thetaMax_given = 1;
            args_info->thetaMax_given = 1;
            args_info->thetaMax_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->thetaMax_orig)
              free (args_info->thetaMax_orig); /* free previous string */
            args_info->thetaMax_orig = gengetopt_strdup (optarg);
          }
          /* thetaStep for Hough transform (in degrees).  */
          else if (strcmp (long_options[option_index].name, "thetaStep") == 0)
          {
            if (local_args_info.thetaStep_given)
              {
                fprintf (stderr, "%s: `--thetaStep' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->thetaStep_given && ! override)
              continue;
            local_args_info.thetaStep_given = 1;
            args_info->thetaStep_given = 1;
            args_info->thetaStep_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->thetaStep_orig)
              free (args_info->thetaStep_orig); /* free previous string */
            args_info->thetaStep_orig = gengetopt_strdup (optarg);
          }
          /* Portion of IPM image height to add to y-coordinate of VP.  */
          else if (strcmp (long_options[option_index].name, "ipmVpPortion") == 0)
          {
            if (local_args_info.ipmVpPortion_given)
              {
                fprintf (stderr, "%s: `--ipmVpPortion' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ipmVpPortion_given && ! override)
              continue;
            local_args_info.ipmVpPortion_given = 1;
            args_info->ipmVpPortion_given = 1;
            args_info->ipmVpPortion_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ipmVpPortion_orig)
              free (args_info->ipmVpPortion_orig); /* free previous string */
            args_info->ipmVpPortion_orig = gengetopt_strdup (optarg);
          }
          /* Get the endpoints of the line.  */
          else if (strcmp (long_options[option_index].name, "getEndPoints") == 0)
          {
            if (local_args_info.getEndPoints_given)
              {
                fprintf (stderr, "%s: `--getEndPoints' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->getEndPoints_given && ! override)
              continue;
            local_args_info.getEndPoints_given = 1;
            args_info->getEndPoints_given = 1;
            args_info->getEndPoints_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->getEndPoints_orig)
              free (args_info->getEndPoints_orig); /* free previous string */
            args_info->getEndPoints_orig = gengetopt_strdup (optarg);
          }
          /* group nearby lines or not (default 1: group).  */
          else if (strcmp (long_options[option_index].name, "group") == 0)
          {
            if (local_args_info.group_given)
              {
                fprintf (stderr, "%s: `--group' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->group_given && ! override)
              continue;
            local_args_info.group_given = 1;
            args_info->group_given = 1;
            args_info->group_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->group_orig)
              free (args_info->group_orig); /* free previous string */
            args_info->group_orig = gengetopt_strdup (optarg);
          }
          /* Threshold for grouping nearby lines (default 10).  */
          else if (strcmp (long_options[option_index].name, "groupThreshold") == 0)
          {
            if (local_args_info.groupThreshold_given)
              {
                fprintf (stderr, "%s: `--groupThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->groupThreshold_given && ! override)
              continue;
            local_args_info.groupThreshold_given = 1;
            args_info->groupThreshold_given = 1;
            args_info->groupThreshold_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->groupThreshold_orig)
              free (args_info->groupThreshold_orig); /* free previous string */
            args_info->groupThreshold_orig = gengetopt_strdup (optarg);
          }
          /* use RANSAC (1) or not (0).  */
          else if (strcmp (long_options[option_index].name, "ransac") == 0)
          {
            if (local_args_info.ransac_given)
              {
                fprintf (stderr, "%s: `--ransac' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransac_given && ! override)
              continue;
            local_args_info.ransac_given = 1;
            args_info->ransac_given = 1;
            args_info->ransac_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransac_orig)
              free (args_info->ransac_orig); /* free previous string */
            args_info->ransac_orig = gengetopt_strdup (optarg);
          }
          /* Number of samples to use for RANSAC.  */
          else if (strcmp (long_options[option_index].name, "ransacLineNumSamples") == 0)
          {
            if (local_args_info.ransacLineNumSamples_given)
              {
                fprintf (stderr, "%s: `--ransacLineNumSamples' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacLineNumSamples_given && ! override)
              continue;
            local_args_info.ransacLineNumSamples_given = 1;
            args_info->ransacLineNumSamples_given = 1;
            args_info->ransacLineNumSamples_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacLineNumSamples_orig)
              free (args_info->ransacLineNumSamples_orig); /* free previous string */
            args_info->ransacLineNumSamples_orig = gengetopt_strdup (optarg);
          }
          /* Number of iterations to use for RANSAC.  */
          else if (strcmp (long_options[option_index].name, "ransacLineNumIterations") == 0)
          {
            if (local_args_info.ransacLineNumIterations_given)
              {
                fprintf (stderr, "%s: `--ransacLineNumIterations' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacLineNumIterations_given && ! override)
              continue;
            local_args_info.ransacLineNumIterations_given = 1;
            args_info->ransacLineNumIterations_given = 1;
            args_info->ransacLineNumIterations_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacLineNumIterations_orig)
              free (args_info->ransacLineNumIterations_orig); /* free previous string */
            args_info->ransacLineNumIterations_orig = gengetopt_strdup (optarg);
          }
          /* Number of close points to consider a good line fit.  */
          else if (strcmp (long_options[option_index].name, "ransacLineNumGoodFit") == 0)
          {
            if (local_args_info.ransacLineNumGoodFit_given)
              {
                fprintf (stderr, "%s: `--ransacLineNumGoodFit' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacLineNumGoodFit_given && ! override)
              continue;
            local_args_info.ransacLineNumGoodFit_given = 1;
            args_info->ransacLineNumGoodFit_given = 1;
            args_info->ransacLineNumGoodFit_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacLineNumGoodFit_orig)
              free (args_info->ransacLineNumGoodFit_orig); /* free previous string */
            args_info->ransacLineNumGoodFit_orig = gengetopt_strdup (optarg);
          }
          /* Threshold to consider a point close.  */
          else if (strcmp (long_options[option_index].name, "ransacLineThreshold") == 0)
          {
            if (local_args_info.ransacLineThreshold_given)
              {
                fprintf (stderr, "%s: `--ransacLineThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacLineThreshold_given && ! override)
              continue;
            local_args_info.ransacLineThreshold_given = 1;
            args_info->ransacLineThreshold_given = 1;
            args_info->ransacLineThreshold_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacLineThreshold_orig)
              free (args_info->ransacLineThreshold_orig); /* free previous string */
            args_info->ransacLineThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Threshold for detected line scores.  */
          else if (strcmp (long_options[option_index].name, "ransacLineScoreThreshold") == 0)
          {
            if (local_args_info.ransacLineScoreThreshold_given)
              {
                fprintf (stderr, "%s: `--ransacLineScoreThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacLineScoreThreshold_given && ! override)
              continue;
            local_args_info.ransacLineScoreThreshold_given = 1;
            args_info->ransacLineScoreThreshold_given = 1;
            args_info->ransacLineScoreThreshold_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacLineScoreThreshold_orig)
              free (args_info->ransacLineScoreThreshold_orig); /* free previous string */
            args_info->ransacLineScoreThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Whether to binarize image for RANSAC or not.  */
          else if (strcmp (long_options[option_index].name, "ransacLineBinarize") == 0)
          {
            if (local_args_info.ransacLineBinarize_given)
              {
                fprintf (stderr, "%s: `--ransacLineBinarize' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacLineBinarize_given && ! override)
              continue;
            local_args_info.ransacLineBinarize_given = 1;
            args_info->ransacLineBinarize_given = 1;
            args_info->ransacLineBinarize_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacLineBinarize_orig)
              free (args_info->ransacLineBinarize_orig); /* free previous string */
            args_info->ransacLineBinarize_orig = gengetopt_strdup (optarg);
          }
          /* Half width to use for ransac window.  */
          else if (strcmp (long_options[option_index].name, "ransacLineWindow") == 0)
          {
            if (local_args_info.ransacLineWindow_given)
              {
                fprintf (stderr, "%s: `--ransacLineWindow' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacLineWindow_given && ! override)
              continue;
            local_args_info.ransacLineWindow_given = 1;
            args_info->ransacLineWindow_given = 1;
            args_info->ransacLineWindow_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacLineWindow_orig)
              free (args_info->ransacLineWindow_orig); /* free previous string */
            args_info->ransacLineWindow_orig = gengetopt_strdup (optarg);
          }
          /* Number of samples to use for RANSAC.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineNumSamples") == 0)
          {
            if (local_args_info.ransacSplineNumSamples_given)
              {
                fprintf (stderr, "%s: `--ransacSplineNumSamples' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacSplineNumSamples_given && ! override)
              continue;
            local_args_info.ransacSplineNumSamples_given = 1;
            args_info->ransacSplineNumSamples_given = 1;
            args_info->ransacSplineNumSamples_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacSplineNumSamples_orig)
              free (args_info->ransacSplineNumSamples_orig); /* free previous string */
            args_info->ransacSplineNumSamples_orig = gengetopt_strdup (optarg);
          }
          /* Number of iterations to use for RANSAC.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineNumIterations") == 0)
          {
            if (local_args_info.ransacSplineNumIterations_given)
              {
                fprintf (stderr, "%s: `--ransacSplineNumIterations' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacSplineNumIterations_given && ! override)
              continue;
            local_args_info.ransacSplineNumIterations_given = 1;
            args_info->ransacSplineNumIterations_given = 1;
            args_info->ransacSplineNumIterations_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacSplineNumIterations_orig)
              free (args_info->ransacSplineNumIterations_orig); /* free previous string */
            args_info->ransacSplineNumIterations_orig = gengetopt_strdup (optarg);
          }
          /* Number of close points to consider a good line fit.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineNumGoodFit") == 0)
          {
            if (local_args_info.ransacSplineNumGoodFit_given)
              {
                fprintf (stderr, "%s: `--ransacSplineNumGoodFit' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacSplineNumGoodFit_given && ! override)
              continue;
            local_args_info.ransacSplineNumGoodFit_given = 1;
            args_info->ransacSplineNumGoodFit_given = 1;
            args_info->ransacSplineNumGoodFit_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacSplineNumGoodFit_orig)
              free (args_info->ransacSplineNumGoodFit_orig); /* free previous string */
            args_info->ransacSplineNumGoodFit_orig = gengetopt_strdup (optarg);
          }
          /* Threshold to consider a point close.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineThreshold") == 0)
          {
            if (local_args_info.ransacSplineThreshold_given)
              {
                fprintf (stderr, "%s: `--ransacSplineThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacSplineThreshold_given && ! override)
              continue;
            local_args_info.ransacSplineThreshold_given = 1;
            args_info->ransacSplineThreshold_given = 1;
            args_info->ransacSplineThreshold_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacSplineThreshold_orig)
              free (args_info->ransacSplineThreshold_orig); /* free previous string */
            args_info->ransacSplineThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Threshold for detected line scores.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineScoreThreshold") == 0)
          {
            if (local_args_info.ransacSplineScoreThreshold_given)
              {
                fprintf (stderr, "%s: `--ransacSplineScoreThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacSplineScoreThreshold_given && ! override)
              continue;
            local_args_info.ransacSplineScoreThreshold_given = 1;
            args_info->ransacSplineScoreThreshold_given = 1;
            args_info->ransacSplineScoreThreshold_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacSplineScoreThreshold_orig)
              free (args_info->ransacSplineScoreThreshold_orig); /* free previous string */
            args_info->ransacSplineScoreThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Whether to binarize image for RANSAC or not.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineBinarize") == 0)
          {
            if (local_args_info.ransacSplineBinarize_given)
              {
                fprintf (stderr, "%s: `--ransacSplineBinarize' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacSplineBinarize_given && ! override)
              continue;
            local_args_info.ransacSplineBinarize_given = 1;
            args_info->ransacSplineBinarize_given = 1;
            args_info->ransacSplineBinarize_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacSplineBinarize_orig)
              free (args_info->ransacSplineBinarize_orig); /* free previous string */
            args_info->ransacSplineBinarize_orig = gengetopt_strdup (optarg);
          }
          /* Half width to use for ransac window.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineWindow") == 0)
          {
            if (local_args_info.ransacSplineWindow_given)
              {
                fprintf (stderr, "%s: `--ransacSplineWindow' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacSplineWindow_given && ! override)
              continue;
            local_args_info.ransacSplineWindow_given = 1;
            args_info->ransacSplineWindow_given = 1;
            args_info->ransacSplineWindow_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacSplineWindow_orig)
              free (args_info->ransacSplineWindow_orig); /* free previous string */
            args_info->ransacSplineWindow_orig = gengetopt_strdup (optarg);
          }
          /* Degree of spline to use.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineDegree") == 0)
          {
            if (local_args_info.ransacSplineDegree_given)
              {
                fprintf (stderr, "%s: `--ransacSplineDegree' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacSplineDegree_given && ! override)
              continue;
            local_args_info.ransacSplineDegree_given = 1;
            args_info->ransacSplineDegree_given = 1;
            args_info->ransacSplineDegree_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacSplineDegree_orig)
              free (args_info->ransacSplineDegree_orig); /* free previous string */
            args_info->ransacSplineDegree_orig = gengetopt_strdup (optarg);
          }
          /* Whether to use splines.  */
          else if (strcmp (long_options[option_index].name, "ransacSpline") == 0)
          {
            if (local_args_info.ransacSpline_given)
              {
                fprintf (stderr, "%s: `--ransacSpline' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacSpline_given && ! override)
              continue;
            local_args_info.ransacSpline_given = 1;
            args_info->ransacSpline_given = 1;
            args_info->ransacSpline_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacSpline_orig)
              free (args_info->ransacSpline_orig); /* free previous string */
            args_info->ransacSpline_orig = gengetopt_strdup (optarg);
          }
          /* Whether to use lines.  */
          else if (strcmp (long_options[option_index].name, "ransacLine") == 0)
          {
            if (local_args_info.ransacLine_given)
              {
                fprintf (stderr, "%s: `--ransacLine' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacLine_given && ! override)
              continue;
            local_args_info.ransacLine_given = 1;
            args_info->ransacLine_given = 1;
            args_info->ransacLine_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacLine_orig)
              free (args_info->ransacLine_orig); /* free previous string */
            args_info->ransacLine_orig = gengetopt_strdup (optarg);
          }
          /* Step to use when pixelzing spline in ransac.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineStep") == 0)
          {
            if (local_args_info.ransacSplineStep_given)
              {
                fprintf (stderr, "%s: `--ransacSplineStep' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ransacSplineStep_given && ! override)
              continue;
            local_args_info.ransacSplineStep_given = 1;
            args_info->ransacSplineStep_given = 1;
            args_info->ransacSplineStep_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ransacSplineStep_orig)
              free (args_info->ransacSplineStep_orig); /* free previous string */
            args_info->ransacSplineStep_orig = gengetopt_strdup (optarg);
          }
          /* Overlap threshold to use for grouping of bounding boxes.  */
          else if (strcmp (long_options[option_index].name, "overlapThreshold") == 0)
          {
            if (local_args_info.overlapThreshold_given)
              {
                fprintf (stderr, "%s: `--overlapThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->overlapThreshold_given && ! override)
              continue;
            local_args_info.overlapThreshold_given = 1;
            args_info->overlapThreshold_given = 1;
            args_info->overlapThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->overlapThreshold_orig)
              free (args_info->overlapThreshold_orig); /* free previous string */
            args_info->overlapThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Angle threshold used for localization (cosine, 1: most restrictive, 0: most liberal).  */
          else if (strcmp (long_options[option_index].name, "localizeAngleThreshold") == 0)
          {
            if (local_args_info.localizeAngleThreshold_given)
              {
                fprintf (stderr, "%s: `--localizeAngleThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->localizeAngleThreshold_given && ! override)
              continue;
            local_args_info.localizeAngleThreshold_given = 1;
            args_info->localizeAngleThreshold_given = 1;
            args_info->localizeAngleThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->localizeAngleThreshold_orig)
              free (args_info->localizeAngleThreshold_orig); /* free previous string */
            args_info->localizeAngleThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Number of pixels to go in normal direction for localization.  */
          else if (strcmp (long_options[option_index].name, "localizeNumLinePixels") == 0)
          {
            if (local_args_info.localizeNumLinePixels_given)
              {
                fprintf (stderr, "%s: `--localizeNumLinePixels' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->localizeNumLinePixels_given && ! override)
              continue;
            local_args_info.localizeNumLinePixels_given = 1;
            args_info->localizeNumLinePixels_given = 1;
            args_info->localizeNumLinePixels_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->localizeNumLinePixels_orig)
              free (args_info->localizeNumLinePixels_orig); /* free previous string */
            args_info->localizeNumLinePixels_orig = gengetopt_strdup (optarg);
          }
          /* Angle threshold used for extending (cosine, 1: most restrictive, 0: most liberal).  */
          else if (strcmp (long_options[option_index].name, "extendAngleThreshold") == 0)
          {
            if (local_args_info.extendAngleThreshold_given)
              {
                fprintf (stderr, "%s: `--extendAngleThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendAngleThreshold_given && ! override)
              continue;
            local_args_info.extendAngleThreshold_given = 1;
            args_info->extendAngleThreshold_given = 1;
            args_info->extendAngleThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendAngleThreshold_orig)
              free (args_info->extendAngleThreshold_orig); /* free previous string */
            args_info->extendAngleThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Angle threshold from mean direction used for extending (cosine, 1: most restrictive, 0: most liberal).  */
          else if (strcmp (long_options[option_index].name, "extendMeanDirAngleThreshold") == 0)
          {
            if (local_args_info.extendMeanDirAngleThreshold_given)
              {
                fprintf (stderr, "%s: `--extendMeanDirAngleThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendMeanDirAngleThreshold_given && ! override)
              continue;
            local_args_info.extendMeanDirAngleThreshold_given = 1;
            args_info->extendMeanDirAngleThreshold_given = 1;
            args_info->extendMeanDirAngleThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendMeanDirAngleThreshold_orig)
              free (args_info->extendMeanDirAngleThreshold_orig); /* free previous string */
            args_info->extendMeanDirAngleThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Number of pixels to go in tangent direction for extending.  */
          else if (strcmp (long_options[option_index].name, "extendLinePixelsTangent") == 0)
          {
            if (local_args_info.extendLinePixelsTangent_given)
              {
                fprintf (stderr, "%s: `--extendLinePixelsTangent' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendLinePixelsTangent_given && ! override)
              continue;
            local_args_info.extendLinePixelsTangent_given = 1;
            args_info->extendLinePixelsTangent_given = 1;
            args_info->extendLinePixelsTangent_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendLinePixelsTangent_orig)
              free (args_info->extendLinePixelsTangent_orig); /* free previous string */
            args_info->extendLinePixelsTangent_orig = gengetopt_strdup (optarg);
          }
          /* Number of pixels to go in tangent direction for extending.  */
          else if (strcmp (long_options[option_index].name, "extendLinePixelsNormal") == 0)
          {
            if (local_args_info.extendLinePixelsNormal_given)
              {
                fprintf (stderr, "%s: `--extendLinePixelsNormal' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendLinePixelsNormal_given && ! override)
              continue;
            local_args_info.extendLinePixelsNormal_given = 1;
            args_info->extendLinePixelsNormal_given = 1;
            args_info->extendLinePixelsNormal_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendLinePixelsNormal_orig)
              free (args_info->extendLinePixelsNormal_orig); /* free previous string */
            args_info->extendLinePixelsNormal_orig = gengetopt_strdup (optarg);
          }
          /* Threhsold used for stopping the extending process (higher -> less extending).  */
          else if (strcmp (long_options[option_index].name, "extendContThreshold") == 0)
          {
            if (local_args_info.extendContThreshold_given)
              {
                fprintf (stderr, "%s: `--extendContThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendContThreshold_given && ! override)
              continue;
            local_args_info.extendContThreshold_given = 1;
            args_info->extendContThreshold_given = 1;
            args_info->extendContThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendContThreshold_orig)
              free (args_info->extendContThreshold_orig); /* free previous string */
            args_info->extendContThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Stop extending when number of deviating points exceeds this threshold.  */
          else if (strcmp (long_options[option_index].name, "extendDeviationThreshold") == 0)
          {
            if (local_args_info.extendDeviationThreshold_given)
              {
                fprintf (stderr, "%s: `--extendDeviationThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendDeviationThreshold_given && ! override)
              continue;
            local_args_info.extendDeviationThreshold_given = 1;
            args_info->extendDeviationThreshold_given = 1;
            args_info->extendDeviationThreshold_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendDeviationThreshold_orig)
              free (args_info->extendDeviationThreshold_orig); /* free previous string */
            args_info->extendDeviationThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Top point for extension bounding box.  */
          else if (strcmp (long_options[option_index].name, "extendRectTop") == 0)
          {
            if (local_args_info.extendRectTop_given)
              {
                fprintf (stderr, "%s: `--extendRectTop' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendRectTop_given && ! override)
              continue;
            local_args_info.extendRectTop_given = 1;
            args_info->extendRectTop_given = 1;
            args_info->extendRectTop_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendRectTop_orig)
              free (args_info->extendRectTop_orig); /* free previous string */
            args_info->extendRectTop_orig = gengetopt_strdup (optarg);
          }
          /* Bottom point for extension bounding box.  */
          else if (strcmp (long_options[option_index].name, "extendRectBottom") == 0)
          {
            if (local_args_info.extendRectBottom_given)
              {
                fprintf (stderr, "%s: `--extendRectBottom' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendRectBottom_given && ! override)
              continue;
            local_args_info.extendRectBottom_given = 1;
            args_info->extendRectBottom_given = 1;
            args_info->extendRectBottom_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendRectBottom_orig)
              free (args_info->extendRectBottom_orig); /* free previous string */
            args_info->extendRectBottom_orig = gengetopt_strdup (optarg);
          }
          /* Angle threshold used for extending (cosine, 1: most restrictive, 0: most liberal).  */
          else if (strcmp (long_options[option_index].name, "extendIPMAngleThreshold") == 0)
          {
            if (local_args_info.extendIPMAngleThreshold_given)
              {
                fprintf (stderr, "%s: `--extendIPMAngleThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendIPMAngleThreshold_given && ! override)
              continue;
            local_args_info.extendIPMAngleThreshold_given = 1;
            args_info->extendIPMAngleThreshold_given = 1;
            args_info->extendIPMAngleThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendIPMAngleThreshold_orig)
              free (args_info->extendIPMAngleThreshold_orig); /* free previous string */
            args_info->extendIPMAngleThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Angle threshold from mean direction used for extending (cosine, 1: most restrictive, 0: most liberal).  */
          else if (strcmp (long_options[option_index].name, "extendIPMMeanDirAngleThreshold") == 0)
          {
            if (local_args_info.extendIPMMeanDirAngleThreshold_given)
              {
                fprintf (stderr, "%s: `--extendIPMMeanDirAngleThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendIPMMeanDirAngleThreshold_given && ! override)
              continue;
            local_args_info.extendIPMMeanDirAngleThreshold_given = 1;
            args_info->extendIPMMeanDirAngleThreshold_given = 1;
            args_info->extendIPMMeanDirAngleThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendIPMMeanDirAngleThreshold_orig)
              free (args_info->extendIPMMeanDirAngleThreshold_orig); /* free previous string */
            args_info->extendIPMMeanDirAngleThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Number of pixels to go in tangent direction for extending.  */
          else if (strcmp (long_options[option_index].name, "extendIPMLinePixelsTangent") == 0)
          {
            if (local_args_info.extendIPMLinePixelsTangent_given)
              {
                fprintf (stderr, "%s: `--extendIPMLinePixelsTangent' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendIPMLinePixelsTangent_given && ! override)
              continue;
            local_args_info.extendIPMLinePixelsTangent_given = 1;
            args_info->extendIPMLinePixelsTangent_given = 1;
            args_info->extendIPMLinePixelsTangent_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendIPMLinePixelsTangent_orig)
              free (args_info->extendIPMLinePixelsTangent_orig); /* free previous string */
            args_info->extendIPMLinePixelsTangent_orig = gengetopt_strdup (optarg);
          }
          /* Number of pixels to go in tangent direction for extending.  */
          else if (strcmp (long_options[option_index].name, "extendIPMLinePixelsNormal") == 0)
          {
            if (local_args_info.extendIPMLinePixelsNormal_given)
              {
                fprintf (stderr, "%s: `--extendIPMLinePixelsNormal' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendIPMLinePixelsNormal_given && ! override)
              continue;
            local_args_info.extendIPMLinePixelsNormal_given = 1;
            args_info->extendIPMLinePixelsNormal_given = 1;
            args_info->extendIPMLinePixelsNormal_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendIPMLinePixelsNormal_orig)
              free (args_info->extendIPMLinePixelsNormal_orig); /* free previous string */
            args_info->extendIPMLinePixelsNormal_orig = gengetopt_strdup (optarg);
          }
          /* Threhsold used for stopping the extending process (higher -> less extending).  */
          else if (strcmp (long_options[option_index].name, "extendIPMContThreshold") == 0)
          {
            if (local_args_info.extendIPMContThreshold_given)
              {
                fprintf (stderr, "%s: `--extendIPMContThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendIPMContThreshold_given && ! override)
              continue;
            local_args_info.extendIPMContThreshold_given = 1;
            args_info->extendIPMContThreshold_given = 1;
            args_info->extendIPMContThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendIPMContThreshold_orig)
              free (args_info->extendIPMContThreshold_orig); /* free previous string */
            args_info->extendIPMContThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Stop extending when number of deviating points exceeds this threshold.  */
          else if (strcmp (long_options[option_index].name, "extendIPMDeviationThreshold") == 0)
          {
            if (local_args_info.extendIPMDeviationThreshold_given)
              {
                fprintf (stderr, "%s: `--extendIPMDeviationThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendIPMDeviationThreshold_given && ! override)
              continue;
            local_args_info.extendIPMDeviationThreshold_given = 1;
            args_info->extendIPMDeviationThreshold_given = 1;
            args_info->extendIPMDeviationThreshold_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendIPMDeviationThreshold_orig)
              free (args_info->extendIPMDeviationThreshold_orig); /* free previous string */
            args_info->extendIPMDeviationThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Top point for extension bounding box.  */
          else if (strcmp (long_options[option_index].name, "extendIPMRectTop") == 0)
          {
            if (local_args_info.extendIPMRectTop_given)
              {
                fprintf (stderr, "%s: `--extendIPMRectTop' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendIPMRectTop_given && ! override)
              continue;
            local_args_info.extendIPMRectTop_given = 1;
            args_info->extendIPMRectTop_given = 1;
            args_info->extendIPMRectTop_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendIPMRectTop_orig)
              free (args_info->extendIPMRectTop_orig); /* free previous string */
            args_info->extendIPMRectTop_orig = gengetopt_strdup (optarg);
          }
          /* Bottom point for extension bounding box.  */
          else if (strcmp (long_options[option_index].name, "extendIPMRectBottom") == 0)
          {
            if (local_args_info.extendIPMRectBottom_given)
              {
                fprintf (stderr, "%s: `--extendIPMRectBottom' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->extendIPMRectBottom_given && ! override)
              continue;
            local_args_info.extendIPMRectBottom_given = 1;
            args_info->extendIPMRectBottom_given = 1;
            args_info->extendIPMRectBottom_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->extendIPMRectBottom_orig)
              free (args_info->extendIPMRectBottom_orig); /* free previous string */
            args_info->extendIPMRectBottom_orig = gengetopt_strdup (optarg);
          }
          /* Number of pixels to go around the spline to compute score.  */
          else if (strcmp (long_options[option_index].name, "splineScoreJitter") == 0)
          {
            if (local_args_info.splineScoreJitter_given)
              {
                fprintf (stderr, "%s: `--splineScoreJitter' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->splineScoreJitter_given && ! override)
              continue;
            local_args_info.splineScoreJitter_given = 1;
            args_info->splineScoreJitter_given = 1;
            args_info->splineScoreJitter_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->splineScoreJitter_orig)
              free (args_info->splineScoreJitter_orig); /* free previous string */
            args_info->splineScoreJitter_orig = gengetopt_strdup (optarg);
          }
          /* Ratio of spline length to use.  */
          else if (strcmp (long_options[option_index].name, "splineScoreLengthRatio") == 0)
          {
            if (local_args_info.splineScoreLengthRatio_given)
              {
                fprintf (stderr, "%s: `--splineScoreLengthRatio' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->splineScoreLengthRatio_given && ! override)
              continue;
            local_args_info.splineScoreLengthRatio_given = 1;
            args_info->splineScoreLengthRatio_given = 1;
            args_info->splineScoreLengthRatio_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->splineScoreLengthRatio_orig)
              free (args_info->splineScoreLengthRatio_orig); /* free previous string */
            args_info->splineScoreLengthRatio_orig = gengetopt_strdup (optarg);
          }
          /* Ratio of spline angle to use.  */
          else if (strcmp (long_options[option_index].name, "splineScoreAngleRatio") == 0)
          {
            if (local_args_info.splineScoreAngleRatio_given)
              {
                fprintf (stderr, "%s: `--splineScoreAngleRatio' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->splineScoreAngleRatio_given && ! override)
              continue;
            local_args_info.splineScoreAngleRatio_given = 1;
            args_info->splineScoreAngleRatio_given = 1;
            args_info->splineScoreAngleRatio_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->splineScoreAngleRatio_orig)
              free (args_info->splineScoreAngleRatio_orig); /* free previous string */
            args_info->splineScoreAngleRatio_orig = gengetopt_strdup (optarg);
          }
          /* Step to use for spline score computation.  */
          else if (strcmp (long_options[option_index].name, "splineScoreStep") == 0)
          {
            if (local_args_info.splineScoreStep_given)
              {
                fprintf (stderr, "%s: `--splineScoreStep' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->splineScoreStep_given && ! override)
              continue;
            local_args_info.splineScoreStep_given = 1;
            args_info->splineScoreStep_given = 1;
            args_info->splineScoreStep_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->splineScoreStep_orig)
              free (args_info->splineScoreStep_orig); /* free previous string */
            args_info->splineScoreStep_orig = gengetopt_strdup (optarg);
          }
          /* number of frames the track is allowed to be absent before deleting it.  */
          else if (strcmp (long_options[option_index].name, "splineTrackingNumAbsentFrames") == 0)
          {
            if (local_args_info.splineTrackingNumAbsentFrames_given)
              {
                fprintf (stderr, "%s: `--splineTrackingNumAbsentFrames' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->splineTrackingNumAbsentFrames_given && ! override)
              continue;
            local_args_info.splineTrackingNumAbsentFrames_given = 1;
            args_info->splineTrackingNumAbsentFrames_given = 1;
            args_info->splineTrackingNumAbsentFrames_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->splineTrackingNumAbsentFrames_orig)
              free (args_info->splineTrackingNumAbsentFrames_orig); /* free previous string */
            args_info->splineTrackingNumAbsentFrames_orig = gengetopt_strdup (optarg);
          }
          /* number of frames before considering the track good.  */
          else if (strcmp (long_options[option_index].name, "splineTrackingNumSeenFrames") == 0)
          {
            if (local_args_info.splineTrackingNumSeenFrames_given)
              {
                fprintf (stderr, "%s: `--splineTrackingNumSeenFrames' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->splineTrackingNumSeenFrames_given && ! override)
              continue;
            local_args_info.splineTrackingNumSeenFrames_given = 1;
            args_info->splineTrackingNumSeenFrames_given = 1;
            args_info->splineTrackingNumSeenFrames_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->splineTrackingNumSeenFrames_orig)
              free (args_info->splineTrackingNumSeenFrames_orig); /* free previous string */
            args_info->splineTrackingNumSeenFrames_orig = gengetopt_strdup (optarg);
          }
          /* Angle threshold for merging splines (radians).  */
          else if (strcmp (long_options[option_index].name, "mergeSplineThetaThreshold") == 0)
          {
            if (local_args_info.mergeSplineThetaThreshold_given)
              {
                fprintf (stderr, "%s: `--mergeSplineThetaThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->mergeSplineThetaThreshold_given && ! override)
              continue;
            local_args_info.mergeSplineThetaThreshold_given = 1;
            args_info->mergeSplineThetaThreshold_given = 1;
            args_info->mergeSplineThetaThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->mergeSplineThetaThreshold_orig)
              free (args_info->mergeSplineThetaThreshold_orig); /* free previous string */
            args_info->mergeSplineThetaThreshold_orig = gengetopt_strdup (optarg);
          }
          /* R threshold (distance from origin) for merginn splines.  */
          else if (strcmp (long_options[option_index].name, "mergeSplineRThreshold") == 0)
          {
            if (local_args_info.mergeSplineRThreshold_given)
              {
                fprintf (stderr, "%s: `--mergeSplineRThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->mergeSplineRThreshold_given && ! override)
              continue;
            local_args_info.mergeSplineRThreshold_given = 1;
            args_info->mergeSplineRThreshold_given = 1;
            args_info->mergeSplineRThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->mergeSplineRThreshold_orig)
              free (args_info->mergeSplineRThreshold_orig); /* free previous string */
            args_info->mergeSplineRThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Mean Angle threshold for merging splines (radians).  */
          else if (strcmp (long_options[option_index].name, "mergeSplineMeanThetaThreshold") == 0)
          {
            if (local_args_info.mergeSplineMeanThetaThreshold_given)
              {
                fprintf (stderr, "%s: `--mergeSplineMeanThetaThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->mergeSplineMeanThetaThreshold_given && ! override)
              continue;
            local_args_info.mergeSplineMeanThetaThreshold_given = 1;
            args_info->mergeSplineMeanThetaThreshold_given = 1;
            args_info->mergeSplineMeanThetaThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->mergeSplineMeanThetaThreshold_orig)
              free (args_info->mergeSplineMeanThetaThreshold_orig); /* free previous string */
            args_info->mergeSplineMeanThetaThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Mean R threshold (distance from origin) for merginn splines.  */
          else if (strcmp (long_options[option_index].name, "mergeSplineMeanRThreshold") == 0)
          {
            if (local_args_info.mergeSplineMeanRThreshold_given)
              {
                fprintf (stderr, "%s: `--mergeSplineMeanRThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->mergeSplineMeanRThreshold_given && ! override)
              continue;
            local_args_info.mergeSplineMeanRThreshold_given = 1;
            args_info->mergeSplineMeanRThreshold_given = 1;
            args_info->mergeSplineMeanRThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->mergeSplineMeanRThreshold_orig)
              free (args_info->mergeSplineMeanRThreshold_orig); /* free previous string */
            args_info->mergeSplineMeanRThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Distance threshold between spline cetroids for merging.  */
          else if (strcmp (long_options[option_index].name, "mergeSplineCentroidThreshold") == 0)
          {
            if (local_args_info.mergeSplineCentroidThreshold_given)
              {
                fprintf (stderr, "%s: `--mergeSplineCentroidThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->mergeSplineCentroidThreshold_given && ! override)
              continue;
            local_args_info.mergeSplineCentroidThreshold_given = 1;
            args_info->mergeSplineCentroidThreshold_given = 1;
            args_info->mergeSplineCentroidThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->mergeSplineCentroidThreshold_orig)
              free (args_info->mergeSplineCentroidThreshold_orig); /* free previous string */
            args_info->mergeSplineCentroidThreshold_orig = gengetopt_strdup (optarg);
          }
          /* number of frames the track is allowed to be absent before deleting it.  */
          else if (strcmp (long_options[option_index].name, "lineTrackingNumAbsentFrames") == 0)
          {
            if (local_args_info.lineTrackingNumAbsentFrames_given)
              {
                fprintf (stderr, "%s: `--lineTrackingNumAbsentFrames' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->lineTrackingNumAbsentFrames_given && ! override)
              continue;
            local_args_info.lineTrackingNumAbsentFrames_given = 1;
            args_info->lineTrackingNumAbsentFrames_given = 1;
            args_info->lineTrackingNumAbsentFrames_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->lineTrackingNumAbsentFrames_orig)
              free (args_info->lineTrackingNumAbsentFrames_orig); /* free previous string */
            args_info->lineTrackingNumAbsentFrames_orig = gengetopt_strdup (optarg);
          }
          /* number of frames before considering the track good.  */
          else if (strcmp (long_options[option_index].name, "lineTrackingNumSeenFrames") == 0)
          {
            if (local_args_info.lineTrackingNumSeenFrames_given)
              {
                fprintf (stderr, "%s: `--lineTrackingNumSeenFrames' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->lineTrackingNumSeenFrames_given && ! override)
              continue;
            local_args_info.lineTrackingNumSeenFrames_given = 1;
            args_info->lineTrackingNumSeenFrames_given = 1;
            args_info->lineTrackingNumSeenFrames_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->lineTrackingNumSeenFrames_orig)
              free (args_info->lineTrackingNumSeenFrames_orig); /* free previous string */
            args_info->lineTrackingNumSeenFrames_orig = gengetopt_strdup (optarg);
          }
          /* Angle threshold for merging lines (radians).  */
          else if (strcmp (long_options[option_index].name, "mergeLineThetaThreshold") == 0)
          {
            if (local_args_info.mergeLineThetaThreshold_given)
              {
                fprintf (stderr, "%s: `--mergeLineThetaThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->mergeLineThetaThreshold_given && ! override)
              continue;
            local_args_info.mergeLineThetaThreshold_given = 1;
            args_info->mergeLineThetaThreshold_given = 1;
            args_info->mergeLineThetaThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->mergeLineThetaThreshold_orig)
              free (args_info->mergeLineThetaThreshold_orig); /* free previous string */
            args_info->mergeLineThetaThreshold_orig = gengetopt_strdup (optarg);
          }
          /* R threshold (distance from origin) for merging lines.  */
          else if (strcmp (long_options[option_index].name, "mergeLineRThreshold") == 0)
          {
            if (local_args_info.mergeLineRThreshold_given)
              {
                fprintf (stderr, "%s: `--mergeLineRThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->mergeLineRThreshold_given && ! override)
              continue;
            local_args_info.mergeLineRThreshold_given = 1;
            args_info->mergeLineRThreshold_given = 1;
            args_info->mergeLineRThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->mergeLineRThreshold_orig)
              free (args_info->mergeLineRThreshold_orig); /* free previous string */
            args_info->mergeLineRThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Number of horizontal strips to divide the image to.  */
          else if (strcmp (long_options[option_index].name, "numStrips") == 0)
          {
            if (local_args_info.numStrips_given)
              {
                fprintf (stderr, "%s: `--numStrips' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->numStrips_given && ! override)
              continue;
            local_args_info.numStrips_given = 1;
            args_info->numStrips_given = 1;
            args_info->numStrips_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->numStrips_orig)
              free (args_info->numStrips_orig); /* free previous string */
            args_info->numStrips_orig = gengetopt_strdup (optarg);
          }
          /* Whtethet to check splines or not.  */
          else if (strcmp (long_options[option_index].name, "checkSplines") == 0)
          {
            if (local_args_info.checkSplines_given)
              {
                fprintf (stderr, "%s: `--checkSplines' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkSplines_given && ! override)
              continue;
            local_args_info.checkSplines_given = 1;
            args_info->checkSplines_given = 1;
            args_info->checkSplines_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkSplines_orig)
              free (args_info->checkSplines_orig); /* free previous string */
            args_info->checkSplines_orig = gengetopt_strdup (optarg);
          }
          /* Curveness Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkSplinesCurvenessThreshold") == 0)
          {
            if (local_args_info.checkSplinesCurvenessThreshold_given)
              {
                fprintf (stderr, "%s: `--checkSplinesCurvenessThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkSplinesCurvenessThreshold_given && ! override)
              continue;
            local_args_info.checkSplinesCurvenessThreshold_given = 1;
            args_info->checkSplinesCurvenessThreshold_given = 1;
            args_info->checkSplinesCurvenessThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkSplinesCurvenessThreshold_orig)
              free (args_info->checkSplinesCurvenessThreshold_orig); /* free previous string */
            args_info->checkSplinesCurvenessThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Length Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkSplinesLengthThreshold") == 0)
          {
            if (local_args_info.checkSplinesLengthThreshold_given)
              {
                fprintf (stderr, "%s: `--checkSplinesLengthThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkSplinesLengthThreshold_given && ! override)
              continue;
            local_args_info.checkSplinesLengthThreshold_given = 1;
            args_info->checkSplinesLengthThreshold_given = 1;
            args_info->checkSplinesLengthThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkSplinesLengthThreshold_orig)
              free (args_info->checkSplinesLengthThreshold_orig); /* free previous string */
            args_info->checkSplinesLengthThreshold_orig = gengetopt_strdup (optarg);
          }
          /* ThetaDiff Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkSplinesThetaDiffThreshold") == 0)
          {
            if (local_args_info.checkSplinesThetaDiffThreshold_given)
              {
                fprintf (stderr, "%s: `--checkSplinesThetaDiffThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkSplinesThetaDiffThreshold_given && ! override)
              continue;
            local_args_info.checkSplinesThetaDiffThreshold_given = 1;
            args_info->checkSplinesThetaDiffThreshold_given = 1;
            args_info->checkSplinesThetaDiffThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkSplinesThetaDiffThreshold_orig)
              free (args_info->checkSplinesThetaDiffThreshold_orig); /* free previous string */
            args_info->checkSplinesThetaDiffThreshold_orig = gengetopt_strdup (optarg);
          }
          /* ThetaThreshold Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkSplinesThetaThreshold") == 0)
          {
            if (local_args_info.checkSplinesThetaThreshold_given)
              {
                fprintf (stderr, "%s: `--checkSplinesThetaThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkSplinesThetaThreshold_given && ! override)
              continue;
            local_args_info.checkSplinesThetaThreshold_given = 1;
            args_info->checkSplinesThetaThreshold_given = 1;
            args_info->checkSplinesThetaThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkSplinesThetaThreshold_orig)
              free (args_info->checkSplinesThetaThreshold_orig); /* free previous string */
            args_info->checkSplinesThetaThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Whtethet to check IPM splines or not.  */
          else if (strcmp (long_options[option_index].name, "checkIPMSplines") == 0)
          {
            if (local_args_info.checkIPMSplines_given)
              {
                fprintf (stderr, "%s: `--checkIPMSplines' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkIPMSplines_given && ! override)
              continue;
            local_args_info.checkIPMSplines_given = 1;
            args_info->checkIPMSplines_given = 1;
            args_info->checkIPMSplines_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkIPMSplines_orig)
              free (args_info->checkIPMSplines_orig); /* free previous string */
            args_info->checkIPMSplines_orig = gengetopt_strdup (optarg);
          }
          /* Curveness Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkIPMSplinesCurvenessThreshold") == 0)
          {
            if (local_args_info.checkIPMSplinesCurvenessThreshold_given)
              {
                fprintf (stderr, "%s: `--checkIPMSplinesCurvenessThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkIPMSplinesCurvenessThreshold_given && ! override)
              continue;
            local_args_info.checkIPMSplinesCurvenessThreshold_given = 1;
            args_info->checkIPMSplinesCurvenessThreshold_given = 1;
            args_info->checkIPMSplinesCurvenessThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkIPMSplinesCurvenessThreshold_orig)
              free (args_info->checkIPMSplinesCurvenessThreshold_orig); /* free previous string */
            args_info->checkIPMSplinesCurvenessThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Length Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkIPMSplinesLengthThreshold") == 0)
          {
            if (local_args_info.checkIPMSplinesLengthThreshold_given)
              {
                fprintf (stderr, "%s: `--checkIPMSplinesLengthThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkIPMSplinesLengthThreshold_given && ! override)
              continue;
            local_args_info.checkIPMSplinesLengthThreshold_given = 1;
            args_info->checkIPMSplinesLengthThreshold_given = 1;
            args_info->checkIPMSplinesLengthThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkIPMSplinesLengthThreshold_orig)
              free (args_info->checkIPMSplinesLengthThreshold_orig); /* free previous string */
            args_info->checkIPMSplinesLengthThreshold_orig = gengetopt_strdup (optarg);
          }
          /* ThetaDiff Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkIPMSplinesThetaDiffThreshold") == 0)
          {
            if (local_args_info.checkIPMSplinesThetaDiffThreshold_given)
              {
                fprintf (stderr, "%s: `--checkIPMSplinesThetaDiffThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkIPMSplinesThetaDiffThreshold_given && ! override)
              continue;
            local_args_info.checkIPMSplinesThetaDiffThreshold_given = 1;
            args_info->checkIPMSplinesThetaDiffThreshold_given = 1;
            args_info->checkIPMSplinesThetaDiffThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkIPMSplinesThetaDiffThreshold_orig)
              free (args_info->checkIPMSplinesThetaDiffThreshold_orig); /* free previous string */
            args_info->checkIPMSplinesThetaDiffThreshold_orig = gengetopt_strdup (optarg);
          }
          /* ThetaThreshold Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkIPMSplinesThetaThreshold") == 0)
          {
            if (local_args_info.checkIPMSplinesThetaThreshold_given)
              {
                fprintf (stderr, "%s: `--checkIPMSplinesThetaThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkIPMSplinesThetaThreshold_given && ! override)
              continue;
            local_args_info.checkIPMSplinesThetaThreshold_given = 1;
            args_info->checkIPMSplinesThetaThreshold_given = 1;
            args_info->checkIPMSplinesThetaThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkIPMSplinesThetaThreshold_orig)
              free (args_info->checkIPMSplinesThetaThreshold_orig); /* free previous string */
            args_info->checkIPMSplinesThetaThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Final Threshold for declaring a valid spline.  */
          else if (strcmp (long_options[option_index].name, "finalSplineScoreThreshold") == 0)
          {
            if (local_args_info.finalSplineScoreThreshold_given)
              {
                fprintf (stderr, "%s: `--finalSplineScoreThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->finalSplineScoreThreshold_given && ! override)
              continue;
            local_args_info.finalSplineScoreThreshold_given = 1;
            args_info->finalSplineScoreThreshold_given = 1;
            args_info->finalSplineScoreThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->finalSplineScoreThreshold_orig)
              free (args_info->finalSplineScoreThreshold_orig); /* free previous string */
            args_info->finalSplineScoreThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Use groudn plane or not when sending to map.  */
          else if (strcmp (long_options[option_index].name, "useGroundPlane") == 0)
          {
            if (local_args_info.useGroundPlane_given)
              {
                fprintf (stderr, "%s: `--useGroundPlane' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->useGroundPlane_given && ! override)
              continue;
            local_args_info.useGroundPlane_given = 1;
            args_info->useGroundPlane_given = 1;
            args_info->useGroundPlane_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->useGroundPlane_orig)
              free (args_info->useGroundPlane_orig); /* free previous string */
            args_info->useGroundPlane_orig = gengetopt_strdup (optarg);
          }
          /* Whether to check colors or not.  */
          else if (strcmp (long_options[option_index].name, "checkColor") == 0)
          {
            if (local_args_info.checkColor_given)
              {
                fprintf (stderr, "%s: `--checkColor' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkColor_given && ! override)
              continue;
            local_args_info.checkColor_given = 1;
            args_info->checkColor_given = 1;
            args_info->checkColor_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkColor_orig)
              free (args_info->checkColor_orig); /* free previous string */
            args_info->checkColor_orig = gengetopt_strdup (optarg);
          }
          /* Size of window to use.  */
          else if (strcmp (long_options[option_index].name, "checkColorWindow") == 0)
          {
            if (local_args_info.checkColorWindow_given)
              {
                fprintf (stderr, "%s: `--checkColorWindow' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkColorWindow_given && ! override)
              continue;
            local_args_info.checkColorWindow_given = 1;
            args_info->checkColorWindow_given = 1;
            args_info->checkColorWindow_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkColorWindow_orig)
              free (args_info->checkColorWindow_orig); /* free previous string */
            args_info->checkColorWindow_orig = gengetopt_strdup (optarg);
          }
          /* Number of bins to use.  */
          else if (strcmp (long_options[option_index].name, "checkColorNumBins") == 0)
          {
            if (local_args_info.checkColorNumBins_given)
              {
                fprintf (stderr, "%s: `--checkColorNumBins' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkColorNumBins_given && ! override)
              continue;
            local_args_info.checkColorNumBins_given = 1;
            args_info->checkColorNumBins_given = 1;
            args_info->checkColorNumBins_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkColorNumBins_orig)
              free (args_info->checkColorNumBins_orig); /* free previous string */
            args_info->checkColorNumBins_orig = gengetopt_strdup (optarg);
          }
          /* Min ratio of yellow points.  */
          else if (strcmp (long_options[option_index].name, "checkColorNumYellowMin") == 0)
          {
            if (local_args_info.checkColorNumYellowMin_given)
              {
                fprintf (stderr, "%s: `--checkColorNumYellowMin' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkColorNumYellowMin_given && ! override)
              continue;
            local_args_info.checkColorNumYellowMin_given = 1;
            args_info->checkColorNumYellowMin_given = 1;
            args_info->checkColorNumYellowMin_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkColorNumYellowMin_orig)
              free (args_info->checkColorNumYellowMin_orig); /* free previous string */
            args_info->checkColorNumYellowMin_orig = gengetopt_strdup (optarg);
          }
          /* Min RG diff.  */
          else if (strcmp (long_options[option_index].name, "checkColorRGMin") == 0)
          {
            if (local_args_info.checkColorRGMin_given)
              {
                fprintf (stderr, "%s: `--checkColorRGMin' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkColorRGMin_given && ! override)
              continue;
            local_args_info.checkColorRGMin_given = 1;
            args_info->checkColorRGMin_given = 1;
            args_info->checkColorRGMin_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkColorRGMin_orig)
              free (args_info->checkColorRGMin_orig); /* free previous string */
            args_info->checkColorRGMin_orig = gengetopt_strdup (optarg);
          }
          /* Max RG diff.  */
          else if (strcmp (long_options[option_index].name, "checkColorRGMax") == 0)
          {
            if (local_args_info.checkColorRGMax_given)
              {
                fprintf (stderr, "%s: `--checkColorRGMax' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkColorRGMax_given && ! override)
              continue;
            local_args_info.checkColorRGMax_given = 1;
            args_info->checkColorRGMax_given = 1;
            args_info->checkColorRGMax_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkColorRGMax_orig)
              free (args_info->checkColorRGMax_orig); /* free previous string */
            args_info->checkColorRGMax_orig = gengetopt_strdup (optarg);
          }
          /* Min GB diff.  */
          else if (strcmp (long_options[option_index].name, "checkColorGBMin") == 0)
          {
            if (local_args_info.checkColorGBMin_given)
              {
                fprintf (stderr, "%s: `--checkColorGBMin' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkColorGBMin_given && ! override)
              continue;
            local_args_info.checkColorGBMin_given = 1;
            args_info->checkColorGBMin_given = 1;
            args_info->checkColorGBMin_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkColorGBMin_orig)
              free (args_info->checkColorGBMin_orig); /* free previous string */
            args_info->checkColorGBMin_orig = gengetopt_strdup (optarg);
          }
          /* Min RB diff.  */
          else if (strcmp (long_options[option_index].name, "checkColorRBMin") == 0)
          {
            if (local_args_info.checkColorRBMin_given)
              {
                fprintf (stderr, "%s: `--checkColorRBMin' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkColorRBMin_given && ! override)
              continue;
            local_args_info.checkColorRBMin_given = 1;
            args_info->checkColorRBMin_given = 1;
            args_info->checkColorRBMin_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkColorRBMin_orig)
              free (args_info->checkColorRBMin_orig); /* free previous string */
            args_info->checkColorRBMin_orig = gengetopt_strdup (optarg);
          }
          /* RBF Threshold.  */
          else if (strcmp (long_options[option_index].name, "checkColorRBFThreshold") == 0)
          {
            if (local_args_info.checkColorRBFThreshold_given)
              {
                fprintf (stderr, "%s: `--checkColorRBFThreshold' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkColorRBFThreshold_given && ! override)
              continue;
            local_args_info.checkColorRBFThreshold_given = 1;
            args_info->checkColorRBFThreshold_given = 1;
            args_info->checkColorRBFThreshold_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkColorRBFThreshold_orig)
              free (args_info->checkColorRBFThreshold_orig); /* free previous string */
            args_info->checkColorRBFThreshold_orig = gengetopt_strdup (optarg);
          }
          /* Whether to use RBF or not.  */
          else if (strcmp (long_options[option_index].name, "checkColorRBF") == 0)
          {
            if (local_args_info.checkColorRBF_given)
              {
                fprintf (stderr, "%s: `--checkColorRBF' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkColorRBF_given && ! override)
              continue;
            local_args_info.checkColorRBF_given = 1;
            args_info->checkColorRBF_given = 1;
            args_info->checkColorRBF_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkColorRBF_orig)
              free (args_info->checkColorRBF_orig); /* free previous string */
            args_info->checkColorRBF_orig = gengetopt_strdup (optarg);
          }
          /* Whether to clear part of the IPM image.  */
          else if (strcmp (long_options[option_index].name, "ipmWindowClear") == 0)
          {
            if (local_args_info.ipmWindowClear_given)
              {
                fprintf (stderr, "%s: `--ipmWindowClear' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ipmWindowClear_given && ! override)
              continue;
            local_args_info.ipmWindowClear_given = 1;
            args_info->ipmWindowClear_given = 1;
            args_info->ipmWindowClear_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ipmWindowClear_orig)
              free (args_info->ipmWindowClear_orig); /* free previous string */
            args_info->ipmWindowClear_orig = gengetopt_strdup (optarg);
          }
          /* Left corrdinate of window to keep in IPM.  */
          else if (strcmp (long_options[option_index].name, "ipmWindowLeft") == 0)
          {
            if (local_args_info.ipmWindowLeft_given)
              {
                fprintf (stderr, "%s: `--ipmWindowLeft' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ipmWindowLeft_given && ! override)
              continue;
            local_args_info.ipmWindowLeft_given = 1;
            args_info->ipmWindowLeft_given = 1;
            args_info->ipmWindowLeft_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ipmWindowLeft_orig)
              free (args_info->ipmWindowLeft_orig); /* free previous string */
            args_info->ipmWindowLeft_orig = gengetopt_strdup (optarg);
          }
          /* Left corrdinate of window to keep in IPM.  */
          else if (strcmp (long_options[option_index].name, "ipmWindowRight") == 0)
          {
            if (local_args_info.ipmWindowRight_given)
              {
                fprintf (stderr, "%s: `--ipmWindowRight' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->ipmWindowRight_given && ! override)
              continue;
            local_args_info.ipmWindowRight_given = 1;
            args_info->ipmWindowRight_given = 1;
            args_info->ipmWindowRight_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->ipmWindowRight_orig)
              free (args_info->ipmWindowRight_orig); /* free previous string */
            args_info->ipmWindowRight_orig = gengetopt_strdup (optarg);
          }
          /* Whether to check lane width or not.  */
          else if (strcmp (long_options[option_index].name, "checkLaneWidth") == 0)
          {
            if (local_args_info.checkLaneWidth_given)
              {
                fprintf (stderr, "%s: `--checkLaneWidth' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkLaneWidth_given && ! override)
              continue;
            local_args_info.checkLaneWidth_given = 1;
            args_info->checkLaneWidth_given = 1;
            args_info->checkLaneWidth_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkLaneWidth_orig)
              free (args_info->checkLaneWidth_orig); /* free previous string */
            args_info->checkLaneWidth_orig = gengetopt_strdup (optarg);
          }
          /* Mean of lane width to look for.  */
          else if (strcmp (long_options[option_index].name, "checkLaneWidthMean") == 0)
          {
            if (local_args_info.checkLaneWidthMean_given)
              {
                fprintf (stderr, "%s: `--checkLaneWidthMean' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkLaneWidthMean_given && ! override)
              continue;
            local_args_info.checkLaneWidthMean_given = 1;
            args_info->checkLaneWidthMean_given = 1;
            args_info->checkLaneWidthMean_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkLaneWidthMean_orig)
              free (args_info->checkLaneWidthMean_orig); /* free previous string */
            args_info->checkLaneWidthMean_orig = gengetopt_strdup (optarg);
          }
          /* Std deviation of lane width to look for.  */
          else if (strcmp (long_options[option_index].name, "checkLaneWidthStd") == 0)
          {
            if (local_args_info.checkLaneWidthStd_given)
              {
                fprintf (stderr, "%s: `--checkLaneWidthStd' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->checkLaneWidthStd_given && ! override)
              continue;
            local_args_info.checkLaneWidthStd_given = 1;
            args_info->checkLaneWidthStd_given = 1;
            args_info->checkLaneWidthStd_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->checkLaneWidthStd_orig)
              free (args_info->checkLaneWidthStd_orig); /* free previous string */
            args_info->checkLaneWidthStd_orig = gengetopt_strdup (optarg);
          }

          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", LANEDETECTORPARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */



  if (check_required)
    {
      error += LaneDetectorParser_required2 (args_info, argv[0], additional_error);
    }

  LaneDetectorParser_release (&local_args_info);

  if ( error )
    return (EXIT_FAILURE);

  return 0;

failure:

  LaneDetectorParser_release (&local_args_info);
  return (EXIT_FAILURE);
}

#ifndef CONFIG_FILE_LINE_SIZE
#define CONFIG_FILE_LINE_SIZE 2048
#endif
#define ADDITIONAL_ERROR " in configuration file "

#define CONFIG_FILE_LINE_BUFFER_SIZE (CONFIG_FILE_LINE_SIZE+3)
/* 3 is for "--" and "=" */

char my_argv[CONFIG_FILE_LINE_BUFFER_SIZE+1];

int
LaneDetectorParser_configfile (char * const filename, struct LaneDetectorParserInfo *args_info, int override, int initialize, int check_required)
{
  FILE* file;
  char linebuf[CONFIG_FILE_LINE_SIZE];
  int line_num = 0;
  int i, result, equal;
  char *fopt, *farg;
  char *str_index;
  size_t len, next_token;
  char delimiter;
  int my_argc = 0;
  char **my_argv_arg;
  char *additional_error;

  /* store the program name */
  cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
  cmd_line_list_tmp->next = cmd_line_list;
  cmd_line_list = cmd_line_list_tmp;
  cmd_line_list->string_arg = gengetopt_strdup (LANEDETECTORPARSER_PACKAGE);

  if ((file = fopen(filename, "r")) == NULL)
    {
      fprintf (stderr, "%s: Error opening configuration file '%s'\n",
               LANEDETECTORPARSER_PACKAGE, filename);
      result = EXIT_FAILURE;
      goto conf_failure;
    }

  while ((fgets(linebuf, CONFIG_FILE_LINE_SIZE, file)) != NULL)
    {
      ++line_num;
      my_argv[0] = '\0';
      len = strlen(linebuf);
      if (len > (CONFIG_FILE_LINE_BUFFER_SIZE-1))
        {
          fprintf (stderr, "%s:%s:%d: Line too long in configuration file\n",
                   LANEDETECTORPARSER_PACKAGE, filename, line_num);
          result = EXIT_FAILURE;
          goto conf_failure;
        }

      /* find first non-whitespace character in the line */
      next_token = strspn ( linebuf, " \t\r\n");
      str_index  = linebuf + next_token;

      if ( str_index[0] == '\0' || str_index[0] == '#')
        continue; /* empty line or comment line is skipped */

      fopt = str_index;

      /* truncate fopt at the end of the first non-valid character */
      next_token = strcspn (fopt, " \t\r\n=");

      if (fopt[next_token] == '\0') /* the line is over */
        {
          farg  = NULL;
          equal = 0;
          goto noarg;
        }

      /* remember if equal sign is present */
      equal = (fopt[next_token] == '=');
      fopt[next_token++] = '\0';

      /* advance pointers to the next token after the end of fopt */
      next_token += strspn (fopt + next_token, " \t\r\n");
      /* check for the presence of equal sign, and if so, skip it */
      if ( !equal )
        if ((equal = (fopt[next_token] == '=')))
          {
            next_token++;
            next_token += strspn (fopt + next_token, " \t\r\n");
          }
      str_index  += next_token;

      /* find argument */
      farg = str_index;
      if ( farg[0] == '\"' || farg[0] == '\'' )
        { /* quoted argument */
          str_index = strchr (++farg, str_index[0] ); /* skip opening quote */
          if (! str_index)
            {
              fprintf
                (stderr,
                 "%s:%s:%d: unterminated string in configuration file\n",
                 LANEDETECTORPARSER_PACKAGE, filename, line_num);
              result = EXIT_FAILURE;
              goto conf_failure;
            }
        }
      else
        { /* read up the remaining part up to a delimiter */
          next_token = strcspn (farg, " \t\r\n#\'\"");
          str_index += next_token;
        }

      /* truncate farg at the delimiter and store it for further check */
      delimiter = *str_index, *str_index++ = '\0';

      /* everything but comment is illegal at the end of line */
      if (delimiter != '\0' && delimiter != '#')
        {
          str_index += strspn(str_index, " \t\r\n");
          if (*str_index != '\0' && *str_index != '#')
            {
              fprintf
                (stderr,
                 "%s:%s:%d: malformed string in configuration file\n",
                 LANEDETECTORPARSER_PACKAGE, filename, line_num);
              result = EXIT_FAILURE;
              goto conf_failure;
            }
        }

    noarg:
      ++my_argc;
      len = strlen(fopt);

      strcat (my_argv, len > 1 ? "--" : "-");
      strcat (my_argv, fopt);
      if (len > 1 && ((farg &&*farg) || equal))
          strcat (my_argv, "=");
      if (farg && *farg)
          strcat (my_argv, farg);

      cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
      cmd_line_list_tmp->next = cmd_line_list;
      cmd_line_list = cmd_line_list_tmp;
      cmd_line_list->string_arg = gengetopt_strdup(my_argv);
    } /* while */

  ++my_argc; /* for program name */
  my_argv_arg = (char **) malloc((my_argc+1) * sizeof(char *));
  cmd_line_list_tmp = cmd_line_list;
  for (i = my_argc - 1; i >= 0; --i) {
    my_argv_arg[i] = cmd_line_list_tmp->string_arg;
    cmd_line_list_tmp = cmd_line_list_tmp->next;
  }
  my_argv_arg[my_argc] = 0;

  additional_error = (char *)malloc(strlen(filename) + strlen(ADDITIONAL_ERROR) + 1);
  strcpy (additional_error, ADDITIONAL_ERROR);
  strcat (additional_error, filename);
  result =
    LaneDetectorParser_internal (my_argc, my_argv_arg, args_info, override, initialize, check_required, additional_error);

  free (additional_error);
  free (my_argv_arg);

conf_failure:
  if (file)
    fclose(file);

  free_cmd_list();
  if (result == EXIT_FAILURE)
    {
      LaneDetectorParser_free (args_info);
      exit (EXIT_FAILURE);
    }

  return result;
}
