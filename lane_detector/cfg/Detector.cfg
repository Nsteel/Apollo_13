#!/usr/bin/env python
PACKAGE = "lane_detector"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

gen.add("debug_lines", bool_t,   0, "whether to show debug information and images or not", False)

gen.add("draw_boxes", bool_t,   0, "whether to draw the bounding boxes of the lanes or not", False)
gen.add("draw_lines", bool_t,   0, "whether to draw the lines or not", False)

gen.add("ipmWidth",              int_t,   0, "width of IPM image to use",  160, 160, 640)
gen.add("ipmHeight",        int_t,      0, "height of IPM image to use", 120, 120, 480)
gen.add("ipmTop",       int_t,      0, "Top point in original image of region to make IPM for", 220, 50, 220)
gen.add("ipmLeft", int_t,      0, "Left point in original image of region to make IPM for", 10, 10, 150)
gen.add("ipmRight",    int_t,   0, "Right point in original image of region to make IPM for", 640, 300, 640)
gen.add("ipmBottom",        int_t,      0, "Bottom point in original image of region to make IPM for", 480, 300, 480)
gen.add("ipmInterpolation",  int_t,   0, "The method to use for IPM interpolation (default 0: bilinear. 1: NN)", 0, 0, 1)

gen.add("lineWidth",  double_t,   0, "width of line to detect in mm (in the world)", 820, 700, 2000)
gen.add("lineHeight", double_t,   0, "height of line to detect in mm (in the world)", 40, 10, 300)

gen.add("kernelWidth", int_t,   0, "widht of kernel to use for filtering", 3, 1, 30)
gen.add("kernelHeight", int_t,   0, "height of kernel to use for filtering", 3, 1, 30)
gen.add("lowerQuantile", double_t,   0, "lower quantile to use for thresholding the filtered image", 0.975, 0.975, 0.99)

gen.add("localMaxima", bool_t,   0, "whether to return local maxima or just the maximum", True)
gen.add("groupingType", int_t,   0, "type of grouping to use (default 0: HV lines)", 0, 0, 1)
gen.add("binarize", bool_t,   0, "whether to binarize the thresholded image or use the raw values", False)
gen.add("detectionThreshold", double_t,   0, "threshold for line scores to declare as line", 4, 0, 30)
gen.add("smoothScores", bool_t,   0, "whether to smooth scores of lines detected or not", True)

gen.add("rMin", double_t,   0, "rMin for Hough transform (in pixels)", 10, 0, 10)
gen.add("rMax", double_t,   0, "rMax for Hough transform (in pixels)", 150, 120, 300)
gen.add("rStep", double_t,   0, "rStep for Hough transform (in pixels)", 2, 1, 3)
gen.add("thetaMin", double_t,   0, "thetaMin for Hough transform (in degrees)", -45, -45, 85)
gen.add("thetaMax", double_t,   0, "thetaMax for Hough transform (in degrees)", 45, 20, 95)
gen.add("thetaStep", double_t,   0, "thetaStep for Hough transform (in degrees)", 2, 1, 3)

gen.add("ipmVpPortion", double_t,   0, "Portion of IPM image height to add to y-coordinate of VP", 0.0, 0, 0.8)

gen.add("getEndPoints", bool_t,   0, "Get the endpoints of the line", False)
gen.add("group", bool_t,   0, "group nearby lines or not (default 1: group)", True)
gen.add("groupThreshold", double_t,   0, "Threshold for grouping nearby lines (default 10)", 10, 10, 25)

#RANSAC options
gen.add("ransac", bool_t,   0, "use RANSAC (1) or not (0)",  True)
gen.add("ransacLineNumSamples", int_t,   0, "Number of samples to use for RANSAC", 4, 0, 180)
gen.add("ransacLineNumIterations", int_t,   0, "Number of iterations to use for RANSAC", 40, 25, 100)
gen.add("ransacLineNumGoodFit", int_t,   0, "Number of close points to consider a good line fit", 10, 10, 15)
gen.add("ransacLineThreshold", double_t,   0, "Threshold to consider a point close", 0.2, 0, 0.9)
gen.add("ransacLineScoreThreshold", double_t,   0, "Threshold for detected line scores", 0, 0, 20)
gen.add("ransacLineBinarize", bool_t,   0, "Whether to binarize image for RANSAC or not", False)
gen.add("ransacLineWindow", int_t,   0, "Half width to use for ransac window", 15, 0, 15)

gen.add("ransacSplineNumSamples", int_t,   0, "Number of samples to use for RANSAC", 4, 0, 180)
gen.add("ransacSplineNumIterations", int_t,   0, "Number of iterations to use for RANSAC", 40, 25, 100)
gen.add("ransacSplineNumGoodFit", int_t,   0, "Number of close points to consider a good line fit", 10, 10, 15)
gen.add("ransacSplineThreshold", double_t,   0, "Threshold to consider a point close", 0.2, 0, 0.9)
gen.add("ransacSplineScoreThreshold", double_t,   0, "Threshold for detected line scores", 0, 0, 20)
gen.add("ransacSplineBinarize", bool_t,   0, "Whether to binarize image for RANSAC or not", False)
gen.add("ransacSplineWindow", int_t,   0, "Half width to use for ransac window", 10, 6, 15)

gen.add("ransacSplineDegree", int_t,   0, "Degree of spline to use", 3, 2, 5)
gen.add("ransacSpline", bool_t,   0, "Whether to use splines", False)
gen.add("ransacLine", bool_t,   0, "Whether to use lines", True)
gen.add("ransacSplineStep", double_t,   0, "Step to use when pixelzing spline in ransac", 0.1, 0.1, 0.9)

gen.add("overlapThreshold", double_t,   0, "Overlap threshold to use for grouping of bounding boxes", 0.3, 0.3, 0.9)
gen.add("localizeAngleThreshold", double_t,   0, "Angle threshold used for localization (cosine, 1: most restrictive, 0: most liberal)", 0.9, 0.7, 0.9)
gen.add("localizeNumLinePixels", int_t,   0, "Number of pixels to go in normal direction for localization", 20, 10, 20)

gen.add("extendAngleThreshold", double_t,   0, "Angle threshold used for extending (cosine, 1: most restrictive, 0: most liberal)", 0.86, 0.7, 0.95)
gen.add("extendMeanDirAngleThreshold", double_t,   0, "Angle threshold from mean direction used for extending (cosine, 1: most restrictive, 0: most liberal)", 0.95, 0.7, 0.95)
gen.add("extendLinePixelsTangent", int_t,   0, "Number of pixels to go in tangent direction for extending", 10, 5, 20)
gen.add("extendLinePixelsNormal", int_t,   0, "Number of pixels to go in normal direction for extending", 20, 5, 20)
gen.add("extendContThreshold", double_t,   0, "Threhsold used for stopping the extending process (higher -> less extending)", 0.35, 0, 0.35)
gen.add("extendDeviationThreshold", int_t,   0, "Stop extending when number of deviating points exceeds this threshold", 2, 1, 2)
gen.add("extendRectTop", int_t,   0, "Top point for extension bounding box", 200, 100, 200)
gen.add("extendRectBottom", int_t,   0, "Bottom point for extension bounding box", 380, 200, 480)

gen.add("extendIPMAngleThreshold", double_t,   0, "Angle threshold used for extending (cosine, 1: most restrictive, 0: most liberal)", 0.95, 0.7, 0.95)
gen.add("extendIPMMeanDirAngleThreshold", double_t,   0, "Angle threshold from mean direction used for extending (cosine, 1: most restrictive, 0: most liberal)", 0.86, 0.7, 0.95)
gen.add("extendIPMLinePixelsTangent", int_t,   0, "Number of pixels to go in tangent direction for extending", 5, 5, 20)
gen.add("extendIPMLinePixelsNormal", int_t,   0, "Number of pixels to go in normal direction for extending", 10, 5, 20)
gen.add("extendIPMContThreshold", double_t,   0, "Threhsold used for stopping the extending process (higher -> less extending)", 0.05, 0, 0.35)
gen.add("extendIPMDeviationThreshold", int_t,   0, "Stop extending when number of deviating points exceeds this threshold", 2, 1, 2)
gen.add("extendIPMRectTop", int_t,   0, "Top point for extension bounding box", 0, 0, 200)
gen.add("extendIPMRectBottom", int_t,   0, "Bottom point for extension bounding box", 118, 100, 480)

gen.add("splineScoreJitter", int_t,   0, "Number of pixels to go around the spline to compute score", 2, 2, 4)
gen.add("splineScoreLengthRatio", double_t,   0, "Ratio of spline length to use", 1.5, 0.4, 1.5)
gen.add("splineScoreAngleRatio", double_t,   0, "Ratio of spline angle to use", 1.2, 0.8, 1.7)
gen.add("splineScoreStep", double_t,   0, "Step to use for spline score computation", 0.01, 0.01, 0.02)

gen.add("splineTrackingNumAbsentFrames", int_t,   0, "number of frames the track is allowed to be absent before deleting it", 3, 0, 60)
gen.add("splineTrackingNumSeenFrames", int_t,   0, "number of frames before considering the track good", 5, 0, 60)

gen.add("mergeSplineThetaThreshold", double_t,   0, "Angle threshold for merging splines (radians)", 0.3, 0.2, 0.52)
gen.add("mergeSplineRThreshold", double_t,   0, "R threshold (distance from origin) for merging splines", 15, 10, 30)
gen.add("mergeSplineMeanThetaThreshold", double_t,   0, "Mean Angle threshold for merging splines (radians)", 0.2, 0.2, 0.52)
gen.add("mergeSplineMeanRThreshold", double_t,   0, "Mean R threshold (distance from origin) for merging splines", 20, 10, 30)
gen.add("mergeSplineCentroidThreshold", double_t,   0, "Distance threshold between spline cetroids for merging", 80, 50, 90)

gen.add("lineTrackingNumAbsentFrames", int_t,   0, "number of frames the track is allowed to be absent before deleting it", 2, 0, 60)
gen.add("lineTrackingNumSeenFrames", int_t,   0, "number of frames before considering the track good", 3, 0, 60)

gen.add("mergeLineThetaThreshold", double_t,   0, "Angle threshold for merging lines (radians)", 0.3, 0.2, 0.52)
gen.add("mergeLineRThreshold", double_t,   0, "R threshold (distance from origin) for merging lines", 15, 10, 30)

gen.add("numStrips", int_t,   0, "Number of horizontal strips to divide the image to", 1, 1, 20)

gen.add("checkSplines", bool_t,   0, "Whtethet to check splines or not", True)
gen.add("checkSplinesCurvenessThreshold", double_t,   0, "Curveness Threshold for checking splines", 0.8, 0.6, .95)
gen.add("checkSplinesLengthThreshold", double_t,   0, "Length Threshold for checking splines", 30, 10, 50)
gen.add("checkSplinesThetaDiffThreshold", double_t,   0, "ThetaDiff Threshold for checking splines", 0.1, 0.05, 0.4)
gen.add("checkSplinesThetaThreshold", double_t,   0, "ThetaThreshold Threshold for checking splines (radians)", 1.22, 1.0, 1.4)

gen.add("checkIPMSplines", bool_t,   0, True)
gen.add("checkIPMSplinesCurvenessThreshold", double_t,   0, "Curveness Threshold for checking splines", 0.8, 0.6, 0.95)
gen.add("checkIPMSplinesLengthThreshold", double_t,   0, "Length Threshold for checking splines", 30, 10, 50)
gen.add("checkIPMSplinesThetaDiffThreshold", double_t,   0, "ThetaDiff Threshold for checking splines", 0.1, 0.05, 0.4)
gen.add("checkIPMSplinesThetaThreshold", double_t,   0, "ThetaThreshold Threshold for checking splines", 1.22, 1.0, 1.4)

gen.add("finalSplineScoreThreshold", double_t,   0, "Final Threshold for declaring a valid spline", 0, 0, 4)

gen.add("useGroundPlane", bool_t,   0, "Use ground plane or not when sending to map", False)

gen.add("checkColor", bool_t,   0, "Whether to check colors or not", False)
gen.add("checkColorWindow", int_t,   0, "Size of window to use", 3, 1, 10)
gen.add("checkColorNumBins", int_t,   0, "Number of bins to use", 16, 2, 30)
gen.add("checkColorNumYellowMin", double_t,   0, "Min ratio of yellow points", 0.3, 0.1, 0.9)
gen.add("checkColorRGMin", double_t,   0, "Min RG diff", 1, 1, 5)
gen.add("checkColorRGMax", double_t,   0, "Max RG diff", 40, 20, 60)
gen.add("checkColorGBMin", double_t,   0, "Min GB diff", 10, 4, 30)
gen.add("checkColorRBMin", double_t,   0, "Min RB diff", 25, 4, 30)
gen.add("checkColorRBFThreshold", double_t,   0, "RBF Threshold", -0.1, -0.1, 0)
gen.add("checkColorRBF", bool_t,   0, True)

gen.add("ipmWindowClear", bool_t,   0, "Whether to clear part of the IPM image", False)
gen.add("ipmWindowLeft", int_t,   0, "Left cordinate of window to keep in IPM", 50, 10, 320)
gen.add("ipmWindowRight", int_t,   0, "Right cordinate of window to keep in IPM", 110, 100, 480)

gen.add("checkLaneWidth", bool_t,   0, "Whether to check lane width or not", False)
gen.add("checkLaneWidthMean", double_t,   0, "Mean of lane width to look for", 19, 10, 40)
gen.add("checkLaneWidthStd", double_t,   0, "Std deviation of lane width to look for", 10, 1, 20)

exit(gen.generate(PACKAGE, "lane_detector", "Detector"))
